"""specify 命令的模板实现。

该模板用于生成 specify 命令的完整工作流指令，包括：
- 创建新的变更规格说明
- 从用户描述中提取功能要点
- 生成 proposal.md 文件
- 执行完整的质量验证流程

参考：Spec-Kit 的 specify 工作流设计
"""

from .base import CommandTemplate, CommandTemplateContext


class SpecifyTemplate(CommandTemplate):
    """specify 命令的模板实现。

    该模板指导 AI 工具完成变更规格说明的创建，包括名称生成、
    目录结构创建、proposal.md 填充、质量验证和用户交互处理。
    融合了 OpenSpec 和 Spec-Kit 的设计精华。
    """

    def get_outline(self, ctx: CommandTemplateContext) -> str:
        """获取 specify 命令的大纲描述。

        参数：
            ctx: 模板渲染上下文

        返回：
            大纲文本（Markdown 格式）
        """
        return """
创建或更新变更规格说明（Change Proposal），将自然语言描述转换为结构化的变更提案。

**核心目标：**
- 从用户输入中提取关键信息（背景、目标、影响范围）
- 生成符合项目规范的变更名称（action-noun 格式）
- 创建结构化的 proposal.md 文件（WHY、WHAT、IMPACT）
- 执行完整的规格质量验证流程
- 处理需要用户澄清的模糊点（最多 3 个）

**适用场景：**
- 创建新的变更提案（使用变更名称）
- 编辑已有变更提案（使用变更 ID，如 C-001）

**输出产物：**
- `.cc-spec/changes/{变更名称}/proposal.md` - 变更规格文档
- `.cc-spec/changes/{变更名称}/status.yaml` - 状态追踪文件
- 变更 ID（C-XXX 格式）

**关键原则：**
- 聚焦「是什么」和「为什么」，避免「如何实现」
- 面向业务利益相关者，技术和非技术人员共同可读
- 每个需求必须可测试、可验证、无歧义
- 最多 3 个澄清标记，其他不明确处做合理推测
""".strip()

    def get_execution_steps(self, ctx: CommandTemplateContext) -> list[str]:
        """获取 specify 命令的执行步骤列表。

        参数：
            ctx: 模板渲染上下文

        返回：
            执行步骤列表
        """
        return [
            # 步骤 1: 生成变更名称
            "**生成简洁的变更名称**（2-4 个单词）：\n"
            "   - 分析用户输入的特性描述（$ARGUMENTS），提取最核心的关键词\n"
            "   - 创建 2-4 词的短名称，捕捉特性本质\n"
            "   - 使用「动作-名词」格式（如 `add-oauth`, `fix-payment-bug`, `update-api-docs`）\n"
            "   - 保留技术术语和缩写（OAuth2, API, JWT 等）\n"
            "   - 格式要求：\n"
            "     • 必须以小写字母开头\n"
            "     • 仅包含小写字母、数字和连字符（-）\n"
            "     • 长度不超过 64 个字符\n"
            "   - 命名示例：\n"
            "     • 「添加用户认证功能」→ `add-user-auth`\n"
            "     • 「实现 OAuth2 API 集成」→ `oauth2-api-integration`\n"
            "     • 「创建分析仪表板」→ `analytics-dashboard`\n"
            "     • 「修复支付处理超时 bug」→ `fix-payment-timeout`",

            # 步骤 2: 检查变更是否已存在
            "**检查变更是否已存在**：\n"
            "   - 运行 `cc-spec list` 查看当前所有活跃变更\n"
            "   - 检查生成的变更名称是否与已有变更重复\n"
            "   - 如果变更名称已存在：\n"
            "     • 获取该变更的 ID（C-XXX 格式）\n"
            "     • 提示用户：「变更 {名称} 已存在（ID: C-XXX）」\n"
            "     • 建议用户使用 `cc-spec specify C-XXX` 编辑已有变更\n"
            "     • 或生成新的不重复的变更名称\n"
            "   - 如果是新变更，继续下一步",

            # 步骤 3: Git 分支检查（可选）
            "**Git 分支检查**（可选，建议执行）：\n"
            "   a. 首先检查是否为 Git 仓库：运行 `git status`\n"
            "      - 如果不是 Git 仓库，跳过此步骤\n"
            "   b. 获取最新的远程分支信息：\n"
            "      ```bash\n"
            "      git fetch --all --prune\n"
            "      ```\n"
            "   c. 检查是否存在相同名称的分支：\n"
            "      - 远程分支：`git ls-remote --heads origin | grep \"refs/heads/{变更名称}$\"`\n"
            "      - 本地分支：`git branch | grep \"^[* ]*{变更名称}$\"`\n"
            "   d. 如果发现同名分支：\n"
            "      - 提示用户已存在同名分支\n"
            "      - 建议用户选择新的变更名称或清理旧分支\n"
            "   e. 检查工作区状态：\n"
            "      - 运行 `git status --porcelain` 检查未提交的修改\n"
            "      - 如果有未提交的修改，建议用户先提交或暂存",

            # 步骤 4: 创建变更结构
            "**创建变更结构**（仅针对新变更）：\n"
            "   - 运行 `cc-spec specify {变更名称}` 创建变更目录和文件\n"
            "   - 命令会自动执行以下操作：\n"
            "     • 创建 `.cc-spec/changes/{变更名称}/` 目录\n"
            "     • 生成 `proposal.md` 模板文件\n"
            "     • 初始化 `status.yaml` 状态文件\n"
            "     • 分配唯一的变更 ID（C-XXX 格式）\n"
            "   - 记录生成的变更 ID，后续步骤需要使用\n"
            "   - 确认命令执行成功，检查文件是否已创建",

            # 步骤 5: 填充 proposal.md
            "**填充 proposal.md 内容**：\n"
            "   - 使用 Read 工具读取生成的 `proposal.md` 模板\n"
            "   - 使用 Edit 工具编辑 `.cc-spec/changes/{变更名称}/proposal.md`\n"
            "   - 按以下流程填充各章节：\n\n"
            "   **步骤 A：解析用户输入**\n"
            "   - 从 $ARGUMENTS 中提取关键概念（参与者、行动、数据、约束）\n"
            "   - 识别核心需求和业务价值\n"
            "   - 如果描述为空，报错：「未提供特性描述」\n\n"
            "   **步骤 B：填充 Why 章节**\n"
            "   - 说明背景、动机和要解决的问题\n"
            "   - 描述业务价值和用户痛点\n"
            "   - 解释为什么需要这个变更\n\n"
            "   **步骤 C：填充 What Changes 章节**\n"
            "   - 列出具体改动内容（功能点、行为变更、数据变更）\n"
            "   - 每个改动必须可测试且有明确的验收标准\n"
            "   - 使用合理默认值处理未明确的细节（在 Assumptions 章节记录假设）\n\n"
            "   **步骤 D：填充 Impact 章节**\n"
            "   - 列出受影响的规格文件（如果有）\n"
            "   - 描述预期的代码改动区域（模块/组件级别，不涉及具体实现）\n"
            "   - 识别潜在的副作用或风险\n\n"
            "   **步骤 E：处理不明确的方面**\n"
            "   - 对于不明确的细节，首先基于上下文和行业标准做合理推测\n"
            "   - 仅在以下情况使用 `[需要澄清: 具体问题]` 标记（**最多 3 个**）：\n"
            "     • 选择显著影响特性范围或用户体验\n"
            "     • 存在多种合理解释且后果不同\n"
            "     • 无任何合理默认值\n"
            "   - 澄清优先级：范围 > 安全/隐私 > 用户体验 > 技术细节\n"
            "   - 超过 3 处不明确点时，保留最关键的 3 个，其他做合理推测\n\n"
            "   **步骤 F：添加可选章节（如适用）**\n"
            "   - **Success Criteria**：定义可衡量的成功标准（必须与技术无关）\n"
            "   - **User Scenarios**：描述用户使用场景和工作流\n"
            "   - **Key Entities**：列出关键实体（如果涉及数据）\n"
            "   - **Assumptions**：记录所有合理推测和假设\n"
            "   - **Dependencies**：列出依赖的其他变更或外部系统\n\n"
            "   **质量要求：**\n"
            "   - 聚焦「是什么」和「为什么」，避免「如何实现」\n"
            "   - 不涉及编程语言、框架、库、API 端点等实现细节\n"
            "   - 面向业务利益相关者，非技术人员也能理解\n"
            "   - 每个需求可测试、可验证、无歧义",

            # 步骤 6: 规格质量验证
            "**规格质量验证**：\n"
            "   - 针对以下标准逐项验证 proposal.md：\n\n"
            "   **A. 内容质量检查**\n"
            "   - [ ] 无实现细节（无编程语言、框架、库、API 名称）\n"
            "   - [ ] 聚焦用户价值和业务需求\n"
            "   - [ ] 面向非技术利益相关者编写\n"
            "   - [ ] 所有必需章节（Why, What Changes, Impact）已完成且非空\n\n"
            "   **B. 需求完整性检查**\n"
            "   - [ ] 无 `[需要澄清]` 标记残留（或 ≤3 个且已向用户询问）\n"
            "   - [ ] 所有需求可测试且无歧义\n"
            "   - [ ] 成功标准可衡量（如有 Success Criteria 章节）\n"
            "   - [ ] 成功标准与技术无关（无实现细节）\n"
            "   - [ ] 验收场景已定义（如有 User Scenarios 章节）\n"
            "   - [ ] 边界情况已识别\n"
            "   - [ ] 范围边界清晰\n"
            "   - [ ] 依赖和假设已识别\n\n"
            "   **C. 特性就绪度检查**\n"
            "   - [ ] 所有功能需求有明确的验收标准\n"
            "   - [ ] 用户场景覆盖主要流程\n"
            "   - [ ] 特性满足成功标准中定义的可衡量结果\n"
            "   - [ ] 无实现细节泄露到规格中\n\n"
            "   **处理验证结果：**\n"
            "   - 如果所有项通过，继续下一步\n"
            "   - 如果有项未通过（不包括 `[需要澄清]`）：\n"
            "     1. 列出未通过的项和具体问题（引用相关规格章节）\n"
            "     2. 更新 proposal.md 解决每个问题\n"
            "     3. 重新运行验证（最多 3 次迭代）\n"
            "     4. 如果 3 次迭代后仍有未通过项，记录剩余问题并警告用户\n"
            "   - 如果有 `[需要澄清]` 标记残留：\n"
            "     1. 提取所有 `[需要澄清: ...]` 标记\n"
            "     2. 限制检查：如果超过 3 个，仅保留 3 个最关键的（按范围/安全/UX 影响）\n"
            "     3. 对于每个澄清点（最多 3 个），以结构化格式向用户提问：\n"
            "        ```markdown\n"
            "        ## 问题 [N]：[主题]\n"
            "        \n"
            "        **上下文**：[引用相关规格章节]\n"
            "        \n"
            "        **需要了解**：[NEEDS CLARIFICATION 标记中的具体问题]\n"
            "        \n"
            "        **建议答案**：\n"
            "        \n"
            "        | 选项 | 答案 | 影响 |\n"
            "        |------|------|------|\n"
            "        | A    | [第一个建议答案] | [对特性的影响] |\n"
            "        | B    | [第二个建议答案] | [对特性的影响] |\n"
            "        | C    | [第三个建议答案] | [对特性的影响] |\n"
            "        | 自定义 | 提供您自己的答案 | [如何提供自定义输入] |\n"
            "        \n"
            "        **您的选择**：_[等待用户响应]_\n"
            "        ```\n"
            "     4. 依次编号问题（Q1, Q2, Q3 - 最多 3 个）\n"
            "     5. 一次性展示所有问题，然后等待用户响应\n"
            "     6. 等待用户回答所有问题（如：「Q1: A, Q2: 自定义 - [详情], Q3: B」）\n"
            "     7. 根据用户选择或提供的答案，替换每个 `[需要澄清]` 标记\n"
            "     8. 解决所有澄清后重新运行验证",

            # 步骤 7: 完成报告
            "**报告完成**：\n"
            "   - 显示以下信息：\n"
            "     • 变更 ID（C-XXX 格式）\n"
            "     • 变更名称\n"
            "     • proposal.md 文件路径（相对于项目根目录）\n"
            "     • 验证结果摘要（通过项/总项数）\n"
            "   - 如果验证完全通过，显示：\n"
            "     ✓ 规格质量验证通过（X/X 项）\n"
            "   - 如果有警告，列出需要关注的问题\n"
            "   - 提示下一步操作：\n"
            "     • 编辑 proposal.md 补充细节（如需要）\n"
            "     • 运行 `cc-spec clarify C-XXX` 进行深入审查和歧义检测\n"
            "     • 或运行 `cc-spec plan C-XXX` 直接生成执行计划和任务",
        ]

    def get_validation_checklist(self, ctx: CommandTemplateContext) -> list[str]:
        """获取 specify 命令的验证检查清单。

        参数：
            ctx: 模板渲染上下文

        返回：
            验证项列表
        """
        return [
            # 基础验证
            "变更名称符合规范（小写字母开头，仅含小写字母、数字、连字符，长度 ≤64）",
            "变更 ID 已正确分配（C-XXX 格式）",
            "`.cc-spec/changes/{变更名称}/` 目录已创建",
            "`.cc-spec/changes/{变更名称}/proposal.md` 文件已创建且大小 >0 字节",
            "`.cc-spec/changes/{变更名称}/status.yaml` 文件已创建",
            "status.yaml 中 current_stage 为 SPECIFY",

            # proposal.md 结构验证
            "proposal.md 包含所有必需章节（## Why, ## What Changes, ## Impact）",
            "Why 章节已填充，清晰说明了背景、动机和要解决的问题",
            "What Changes 章节已填充，详细列出了具体改动内容",
            "Impact 章节已填充，明确了影响范围（受影响的规格文件、预期代码改动）",
            "所有必需章节均有实质内容（非空，非仅占位符或 TODO）",

            # 内容质量验证
            "规格无实现细节（无编程语言名称、框架名称、库名称、API 端点）",
            "规格聚焦用户价值和业务需求，面向非技术人员可读",
            "所有功能需求可测试且无歧义（有明确的验收标准）",
            "所有需求描述具体且可验证（避免模糊词汇如「改进」「优化」）",

            # 澄清标记验证
            "`[需要澄清]` 或 `[NEEDS CLARIFICATION]` 标记数量 ≤3 处",
            "如有澄清标记，已向用户提问并获得答案（或标记数量在限制内）",
            "所有澄清标记后都说明了需要澄清的具体问题",

            # 成功标准验证（如适用）
            "如有 Success Criteria 章节，所有标准可衡量（包含具体指标）",
            "如有 Success Criteria 章节，所有标准与技术无关（无实现细节）",
            "成功标准从用户/业务视角描述结果，非系统内部指标",

            # 完整性验证
            "如有 Assumptions 章节，所有合理推测和假设已记录",
            "如有 Dependencies 章节，所有依赖已识别并列出",
            "边界情况和约束已在相应章节中识别",
            "范围边界清晰，明确了哪些在范围内、哪些不在范围内",

            # Git 检查（如适用）
            "Git 分支状态检查通过（无同名分支冲突，或已与用户确认）",
            "Git 工作区状态检查通过（无未提交修改，或已与用户确认）",

            # 就绪度验证
            "规格已准备好进入 clarify 或 plan 阶段",
            "变更 ID 和文件路径已正确显示给用户",
            "下一步操作已明确提示给用户",
        ]

    def get_guidelines(self, ctx: CommandTemplateContext) -> str:
        """获取 specify 命令的指南。

        参数：
            ctx: 模板渲染上下文

        返回：
            指南文本（Markdown 格式）
        """
        return """
### 核心原则

- **聚焦「是什么」和「为什么」**：规格描述用户需求和动机，不涉及实现方式
- **避免「如何实现」**：不提及技术栈、API、代码结构、具体算法、数据库表等
- **面向业务利益相关者**：内容应该让非技术人员（产品经理、业务分析师）也能理解
- **限制澄清标记**：最多 3 个 `[需要澄清]`，其他不明确处做合理推测并记录假设

### 编写高质量 proposal.md 的指南

**关注 WHAT 和 WHY，避免 HOW：**

✅ **好的示例**：
- 「添加 OAuth 2.0 登录支持，允许用户使用 GitHub 账号登录」
- 「用户可以在结账时选择多种支付方式（信用卡、PayPal、支付宝）」
- 「系统在用户连续 3 次登录失败后，自动锁定账号 15 分钟」

❌ **不好的示例**（过于技术化）：
- 「在 auth.py 中实现 OAuthHandler 类，使用 requests 库调用 GitHub API」
- 「创建 payment_methods 数据库表，字段包括 id, user_id, method_type, token」
- 「使用 Redis 存储失败登录计数，键格式为 login_fail:{user_id}」

**面向业务人员编写：**
- 使用业务术语而非技术黑话（「用户认证」而非「JWT token 验证」）
- 说明功能的业务价值（「提高转化率」「改善用户体验」），而非技术实现
- 避免代码片段、类名、函数名、SQL 语句等低层次信息
- 从用户视角描述行为（「用户点击按钮后看到...」而非「系统调用 API...」）

**每个需求必须可测试：**

✅ **好的示例**（可测试）：
- 「用户点击"GitHub 登录"按钮后，跳转到 GitHub 授权页面」
- 「搜索结果在 1 秒内显示，至少包含 10 个相关项目」
- 「购物车中的商品在 24 小时后自动移除」

❌ **不好的示例**（不可测试）：
- 「改进登录体验」（太模糊，无法验证）
- 「提高搜索性能」（没有具体指标）
- 「更好的购物车管理」（「更好」无法量化）

**最多 3 个澄清标记：**
- 仅在关键信息缺失时使用 `[需要澄清: 具体问题]` 或 `[NEEDS CLARIFICATION: ...]`
- 每个标记后必须说明需要澄清的具体问题（不能只写 `[需要澄清]`）
- 超过 3 处标记说明用户描述过于模糊，应主动提问澄清而非继续
- 优先澄清对范围、安全、用户体验有重大影响的问题

**变更名称命名规范：**

✅ **好的命名**：
- 动词-名词格式：`add-oauth-login`, `fix-payment-timeout`, `update-api-docs`
- 简洁明了：`user-auth`, `file-upload`, `email-notifications`
- 保留技术术语：`oauth2-integration`, `jwt-refresh`, `api-rate-limit`

❌ **不好的命名**：
- 过于泛泛：`improve-performance` → 应改为 `optimize-db-queries`
- 包含版本号：`v2-auth` → 应改为 `migrate-to-oauth2`
- 过长：`implement-comprehensive-user-authentication-system` → 应改为 `user-auth-system`
- 大写或空格：`Add-OAuth`, `user auth` → 应改为 `add-oauth`, `user-auth`

### AI 生成指南

当从用户输入创建规格时：

**1. 做合理推测**：
   - 使用上下文、行业标准和常见模式填补空白
   - 基于相似项目的最佳实践做出假设
   - 优先选择简单、标准的解决方案

**2. 记录假设**：
   - 在 Assumptions 章节明确记录所有假设
   - 说明为什么做出这个假设（基于什么依据）
   - 让用户能够轻松识别和修正不合理的假设

**3. 限制澄清**：
   - 最多 3 个 `[需要澄清]` 标记
   - 仅用于关键决策：
     • 显著影响特性范围或用户体验
     • 存在多种合理解释且后果不同
     • 无任何合理默认值
   - 澄清优先级：**范围 > 安全/隐私 > 用户体验 > 技术细节**

**4. 像测试人员一样思考**：
   - 每个模糊需求都应该无法通过「可测试且无歧义」的检查项
   - 问自己：「我能根据这个描述写出明确的测试用例吗？」
   - 如果不能，就需要澄清或使其更具体

**5. 常见需要澄清的领域**（仅在无合理默认值时）：
   - 特性范围和边界（包含/排除特定用例）
   - 用户类型和权限（如有多种冲突解释）
   - 安全/合规要求（如有法律/财务意义）
   - 关键的业务规则（如有多种业务场景）

### 合理默认值示例（不需要询问）

**数据保留**：
- Web 应用：会话 30 分钟，Cookie 30 天
- 日志文件：保留 90 天
- 用户数据：用户主动删除前永久保留

**性能目标**：
- Web 页面加载：< 3 秒
- API 响应：< 500ms
- 搜索结果：< 1 秒
- 支持并发用户：标准 Web 应用 1000-10000

**错误处理**：
- 显示用户友好的错误消息
- 记录详细错误日志供开发者调试
- 提供合理的回退选项

**认证方法**：
- Web 应用：标准会话或 OAuth2
- API：API 密钥或 JWT
- 移动应用：OAuth2 + Refresh Token

**集成模式**：
- RESTful API（除非有特殊原因使用 GraphQL 或 gRPC）
- JSON 格式数据交换
- HTTPS 加密传输

### 成功标准指南

成功标准（Success Criteria）必须：

**1. 可衡量**：包含具体指标（时间、百分比、计数、比率）

✅ **好的示例**：
- 「用户可在 3 分钟内完成结账流程」
- 「系统支持 10,000 并发用户」
- 「95% 的搜索在 1 秒内返回结果」
- 「任务完成率提高 40%」
- 「用户满意度评分 ≥4.5/5.0」

❌ **不好的示例**（不可衡量）：
- 「系统快速响应」（没有具体时间）
- 「支持大量用户」（多少算「大量」？）
- 「搜索体验改善」（如何衡量「改善」？）

**2. 与技术无关**：不提及框架、语言、数据库、工具

✅ **好的示例**：
- 「用户即时看到搜索结果」
- 「系统处理高峰期流量无性能下降」
- 「数据在用户之间安全隔离」

❌ **不好的示例**（技术特定）：
- 「API 响应时间 < 200ms」→ 应改为「用户即时看到结果」
- 「数据库可处理 1000 TPS」→ 应改为「系统支持 X 并发用户」
- 「React 组件高效渲染」→ 应改为「页面交互流畅无卡顿」
- 「Redis 缓存命中率 > 80%」→ 应改为「频繁访问的数据快速加载」

**3. 以用户为中心**：从用户/业务视角描述结果，非系统内部

✅ **好的示例**：
- 「新用户可在 5 分钟内完成首次登录」
- 「购买转化率提高 25%」
- 「客户支持工单处理时间减少 50%」

❌ **不好的示例**（系统内部指标）：
- 「数据库查询优化到 10ms」（用户不关心数据库查询时间）
- 「代码测试覆盖率 > 80%」（这是开发质量指标，不是用户价值）
- 「CI/CD 流水线运行时间 < 5 分钟」（内部流程，不是用户成果）

**4. 可验证**：无需了解实现细节即可测试/验证

✅ **好的示例**：
- 「用户在 3 次点击内访问任何功能」（可以实际点击验证）
- 「系统在 99.9% 的时间内可用」（可以用监控工具验证）
- 「错误消息对非技术用户清晰易懂」（可以让用户测试验证）

❌ **不好的示例**（需要技术知识验证）：
- 「微服务架构符合 12-factor 原则」（需要了解架构实现）
- 「代码遵循 SOLID 原则」（需要审查代码）
- 「使用最新的安全最佳实践」（太模糊，无法验证）

### 常见陷阱与避免方法

**陷阱 1：在规格中包含代码片段或 API 端点**
- ❌ 「调用 POST /api/v1/users 创建用户」
- ✓ 「系统创建新用户账号并发送欢迎邮件」

**陷阱 2：提及具体的编程语言或框架**
- ❌ 「使用 React Hooks 管理状态」
- ✓ 「界面根据用户操作动态更新」

**陷阱 3：描述数据库模式或表结构**
- ❌ 「users 表包含 id, email, password_hash, created_at 字段」
- ✓ 「系统存储用户基本信息（邮箱、密码、注册时间）」

**陷阱 4：指定具体的第三方库或工具**
- ❌ 「使用 Stripe API 处理支付」
- ✓ 「系统集成第三方支付服务处理信用卡支付」

**陷阱 5：使用技术术语替代业务术语**
- ❌ 「实现 JWT token 刷新机制」
- ✓ 「用户无需频繁重新登录即可保持会话」

**陷阱 6：描述系统内部流程而非用户体验**
- ❌ 「后台任务队列处理邮件发送」
- ✓ 「用户在 5 分钟内收到确认邮件」

**陷阱 7：使用模糊的改进词汇**
- ❌ 「优化性能」「改进体验」「增强安全」
- ✓ 「页面加载时间从 5 秒降至 2 秒」「用户点击按钮后立即看到反馈」

### 最佳实践总结

1. **始终从用户视角出发**：「用户可以...」「系统允许用户...」
2. **使用具体的可衡量指标**：时间、数量、百分比、比率
3. **描述行为和结果**：「发生什么」而非「如何发生」
4. **保持技术中立**：避免绑定特定实现方案
5. **确保可测试性**：每个需求都应该能写出明确的测试用例
6. **记录假设和依赖**：让潜在风险透明化
7. **清晰界定范围**：明确哪些在范围内、哪些不在范围内
""".strip()
