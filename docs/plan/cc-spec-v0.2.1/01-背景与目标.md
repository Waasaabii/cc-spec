# 01 - 背景与目标

## 背景

### 当前痛点

1. **终端操作繁琐**：用户需要在终端执行 cc，再通过 cc-spec chat 调用 cx，流程分散
2. **输出分离困难**：cc 和 cx 的输出混在一起，难以区分编排者和执行者的信息
3. **控制能力有限**：现有 Viewer 只能显示和停止会话，缺乏细粒度控制
4. **项目嵌入问题**：.cc-spec 目录嵌入项目，污染项目结构

### 参考项目

- **opcode**：Claude Code GUI 工具，提供项目管理、Agent 系统、使用统计等功能
- **claudia**：opcode 的 npm 包版本，提供可复用的 React 组件和 Tauri 命令

## 目标

### 核心目标

**将 cc-spec-viewer 改造为规范驱动开发的主入口**：用户在 Viewer 里完成所有操作，无需切换到终端。

### 具体目标

1. **统一入口**：Viewer 作为主界面，直接启动和管理 cc/cx 进程
2. **输出分离**：cc 对话区（主）和 cx 任务面板（辅）分开显示
3. **细粒度控制**：支持暂停/继续/停止 cx 任务
4. **项目不污染**：cc-spec 数据存储在 Viewer 本地，不写入项目目录
5. **保留 CLI**：原有命令行方式照常可用

## 核心原则

### 1. cc 作为编排者

- cc (Claude Code) 负责理解需求、规划任务、调用 cx
- Viewer 只启动和管理 cc 进程，不干预 cc 的决策

### 2. cx 作为执行者

- cx (Codex) 负责执行具体任务、产出代码
- Viewer 显示 cx 的执行状态和输出，提供手动控制

### 3. 不打包 cc

- Viewer 调用用户已安装的 Claude Code
- 支持自动探测或手动配置 cc 路径

### 4. cc-spec 作为 sidecar

- cc-spec CLI 用 PyInstaller 打包，随 Viewer 分发
- 保持与 CLI 版本的功能一致性

## 成功指标

| 指标 | 目标 |
|------|------|
| 主入口替代 | 用户 80% 的操作在 Viewer 完成 |
| 输出分离 | cc/cx 输出清晰区分，无混淆 |
| 控制响应 | 暂停/停止操作 <1s 生效 |
| 首次启动 | Viewer 启动到可用 <3s |
| sidecar 大小 | cc-spec 打包后 <50MB |

## 非目标

1. **不替代 cc**：Viewer 不是 Claude Code 的替代品，只是管理界面
2. **不强制使用**：用户仍可选择在终端使用 cc-spec CLI
3. **不打包 cc/cx**：只打包 cc-spec，cc 和 cx 由用户自行安装

## 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| cc 路径探测失败 | 无法启动 | 提供手动配置选项 |
| sidecar 启动慢 | 用户体验差 | 预加载 + 进度提示 |
| cx 进程僵死 | 无法控制 | 超时检测 + 强制终止 |
| 跨平台兼容 | Windows/macOS/Linux 差异 | 分平台测试 + 适配层 |
