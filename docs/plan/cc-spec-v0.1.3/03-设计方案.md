# 03 - 设计方案

## 1. 整体架构

### 1.1 工作流概览

```
┌─────────────────────────────────────────────────────────────────┐
│                        cc-spec 工作流                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    超简单模式 (quick-delta)                 │  │
│  │      git diff + 描述 ──→ 自动解析 ──→ quick-delta.md       │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    标准模式 (7 步工作流)                    │  │
│  │                                                           │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │            规划阶段 (任意 AI 工具可用)                 │  │  │
│  │  │                                                     │  │  │
│  │  │   init ──→ specify ──→ clarify ──→ plan            │  │  │
│  │  │     │         │          │          │               │  │  │
│  │  │     ↓         ↓          ↓          ↓               │  │  │
│  │  │  config   proposal.md  澄清记录  tasks.md           │  │  │
│  │  └──────────────────────────┬──────────────────────────┘  │  │
│  │                             ↓                             │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │            执行阶段 (仅 Claude Code)                  │  │  │
│  │  │                                                     │  │  │
│  │  │   apply (主 Agent + SubAgent 并发 + Git 锁)         │  │  │
│  │  │     │                                               │  │  │
│  │  │     ├── Wave-0: 串行执行 (基础设施)                  │  │  │
│  │  │     ├── Wave-1: 并行执行 (无依赖任务)                │  │  │
│  │  │     └── Wave-N: 并行执行 ...                        │  │  │
│  │  └──────────────────────────┬──────────────────────────┘  │  │
│  │                             ↓                             │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │            验收阶段 (任意 AI 工具可用)                 │  │  │
│  │  │                                                     │  │
│  │  │   checklist ──────────→ archive                     │  │  │
│  │  │       │                    │                        │  │  │
│  │  │       ↓                    ↓                        │  │  │
│  │  │   四维度打分            Delta 合并                   │  │  │
│  │  │   (≥80分通过)           归档到 archive/             │  │  │
│  │  │       │                                             │  │  │
│  │  │       ↓ <80分                                       │  │  │
│  │  │   打回 apply                                        │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 目录结构

```
project/
├── .cc-spec/                          # 工作流数据目录
│   ├── config.yaml                    # 项目配置 (v1.3)
│   ├── id-map.yaml                    # ID 映射表
│   ├── locks/                         # Git 锁目录 (v1.3 新增)
│   │   └── <task-id>.lock             # 任务锁文件
│   ├── templates/                     # 模板文件
│   │   ├── spec-template.md
│   │   ├── plan-template.md
│   │   ├── tasks-template.md
│   │   └── checklist-template.md
│   ├── specs/                         # 规范文档 (主干)
│   │   └── <capability>/
│   │       └── spec.md
│   └── changes/                       # 变更管理
│       ├── <change-name>/             # 活跃变更
│       │   ├── proposal.md
│       │   ├── plan.md
│       │   ├── tasks.md
│       │   ├── checklist-result.md
│       │   └── status.yaml
│       └── archive/                   # 已归档变更
│           └── YYYY-MM-DD-<name>/
│
├── .claude/commands/cc-spec/          # Claude Code 斜杠命令
├── .cursor/commands/                  # Cursor 斜杠命令
├── .gemini/commands/cc-spec/          # Gemini CLI 斜杠命令
└── ...                                # 其他 AI 工具命令目录
```

## 2. 四维度打分机制 (v1.3 核心)

### 2.1 维度定义

```yaml
scoring_dimensions:
  功能完整性:
    weight: 30          # 权重 30%
    description: "是否满足 spec 中定义的功能需求"
    checklist_keywords:
      - "功能"
      - "实现"
      - "需求"
      - "feature"
      - "implement"

  代码质量:
    weight: 25          # 权重 25%
    description: "是否符合项目编码规范和最佳实践"
    checklist_keywords:
      - "代码"
      - "规范"
      - "重构"
      - "quality"
      - "lint"

  测试覆盖:
    weight: 25          # 权重 25%
    description: "是否有充分的测试用例"
    checklist_keywords:
      - "测试"
      - "test"
      - "覆盖"
      - "用例"
      - "coverage"

  文档同步:
    weight: 20          # 权重 20%
    description: "注释、类型标注、文档是否同步更新"
    checklist_keywords:
      - "文档"
      - "注释"
      - "类型"
      - "doc"
      - "comment"
```

### 2.2 数据结构

```python
# core/scoring.py (v1.3 重构)

from dataclasses import dataclass
from enum import Enum

class Dimension(Enum):
    """打分维度"""
    FUNCTIONALITY = "functionality"  # 功能完整性
    CODE_QUALITY = "code_quality"    # 代码质量
    TEST_COVERAGE = "test_coverage"  # 测试覆盖
    DOCUMENTATION = "documentation"  # 文档同步


@dataclass
class DimensionConfig:
    """维度配置"""
    name: str
    weight: int  # 权重百分比 (0-100)
    description: str
    keywords: list[str]  # 用于自动分类的关键词


@dataclass
class DimensionScore:
    """单个维度的得分"""
    dimension: Dimension
    earned: int      # 获得分数
    max_score: int   # 满分
    percentage: float  # 百分比
    items: list[CheckItem]  # 该维度下的检查项


@dataclass
class TaskScore:
    """单个任务的打分结果"""
    task_id: str
    dimension_scores: dict[Dimension, DimensionScore]
    total_score: float      # 加权总分 (0-100)
    passed: bool            # 是否通过
    failed_dimensions: list[Dimension]  # 未通过的维度


@dataclass
class ChecklistResult:
    """完整的 checklist 结果"""
    task_scores: list[TaskScore]
    overall_score: float    # 整体加权平均分
    overall_passed: bool    # 是否整体通过
    threshold: int          # 通过阈值
    failed_tasks: list[str]  # 未通过的任务 ID
    recommendations: list[str]  # 改进建议
```

### 2.3 打分算法

```python
def calculate_task_score(
    task_id: str,
    checklist_items: list[CheckItem],
    dimension_config: dict[Dimension, DimensionConfig],
    threshold: int = 80,
) -> TaskScore:
    """
    计算单个任务的四维度加权得分

    算法:
    1. 根据关键词将 checklist 项分类到各维度
    2. 计算每个维度的得分率
    3. 按权重计算加权总分
    4. 判断是否通过阈值
    """
    # 1. 分类 checklist 项到各维度
    dimension_items: dict[Dimension, list[CheckItem]] = {
        dim: [] for dim in Dimension
    }

    for item in checklist_items:
        dimension = _classify_item(item, dimension_config)
        dimension_items[dimension].append(item)

    # 2. 计算每个维度得分
    dimension_scores = {}
    for dim, items in dimension_items.items():
        if not items:
            # 该维度无检查项，跳过
            continue

        passed = sum(1 for i in items if i.status == CheckStatus.PASSED)
        total = len(items)
        percentage = (passed / total * 100) if total > 0 else 0

        dimension_scores[dim] = DimensionScore(
            dimension=dim,
            earned=passed * 10,
            max_score=total * 10,
            percentage=percentage,
            items=items,
        )

    # 3. 计算加权总分
    weighted_sum = 0
    total_weight = 0
    for dim, score in dimension_scores.items():
        weight = dimension_config[dim].weight
        weighted_sum += score.percentage * weight
        total_weight += weight

    total_score = weighted_sum / total_weight if total_weight > 0 else 0

    # 4. 判断通过状态
    passed = total_score >= threshold
    failed_dimensions = [
        dim for dim, score in dimension_scores.items()
        if score.percentage < threshold
    ]

    return TaskScore(
        task_id=task_id,
        dimension_scores=dimension_scores,
        total_score=total_score,
        passed=passed,
        failed_dimensions=failed_dimensions,
    )
```

### 2.4 输出格式

```markdown
# Checklist Report

**Change**: add-user-auth
**Date**: 2025-01-15
**Threshold**: 80%

## 总览

| Task-ID | 总分 | 功能 | 质量 | 测试 | 文档 | 状态 |
|---------|------|------|------|------|------|------|
| 01-SETUP | 92 | 95 | 90 | 88 | 95 | ✅ PASS |
| 02-MODEL | 65 | 70 | 60 | 55 | 80 | ❌ FAIL |
| 03-API | 88 | 90 | 85 | 85 | 95 | ✅ PASS |

**整体得分**: 81.7% (3/3 任务)
**状态**: ⚠️ 部分通过

## 未通过任务详情

### 02-MODEL (65分) ❌

#### 功能完整性 (70/100)
- [x] 创建 User 数据模型 (10/10)
- [x] 添加字段验证 (10/10)
- [ ] 实现密码加密 (0/10) ← **缺失**
- [x] 创建数据库迁移 (10/10)

#### 代码质量 (60/100)
- [x] 遵循命名规范 (10/10)
- [ ] 添加类型标注 (0/10) ← **不完整**
- [ ] 通过 lint 检查 (0/10) ← **有警告**

#### 测试覆盖 (55/100)
- [x] 单元测试 - 创建 (10/10)
- [ ] 单元测试 - 验证 (0/10) ← **缺失**
- [ ] 集成测试 (0/10) ← **缺失**

#### 文档同步 (80/100)
- [x] 添加 docstring (10/10)
- [x] 更新 API 文档 (10/10)

**修复建议**:
1. 实现密码加密功能 (功能)
2. 补充类型标注 (质量)
3. 添加验证逻辑的单元测试 (测试)

---

## 下一步

❌ 未通过阈值，需要返工
→ 运行 `cc-spec clarify 02-MODEL` 标记任务返工
→ 修复后重新运行 `cc-spec checklist`
```

## 3. Git 分布式锁 (v1.3 新增)

### 3.1 锁机制设计

```yaml
锁类型:
  文件锁:
    位置: .cc-spec/locks/<task-id>.lock
    内容: JSON (agent_id, started_at, timeout)
    用途: 防止同一任务被多个实例执行

  commit 锁 (可选):
    格式: git commit -m "lock: Task-XX by agent-xxx"
    用途: 分布式环境下的协调

锁生命周期:
  获取锁:
    1. 检查 .cc-spec/locks/<task-id>.lock 是否存在
    2. 如果存在且未超时 → 等待或跳过
    3. 如果不存在或已超时 → 创建锁文件
    4. (可选) git commit -m "lock: ..."

  释放锁:
    1. 删除 .cc-spec/locks/<task-id>.lock
    2. (可选) git commit -m "unlock: ..."

  超时释放:
    默认超时: 30 分钟
    超时后其他实例可以强制获取锁
```

### 3.2 数据结构

```python
# core/lock.py (v1.3 新增)

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
import json


@dataclass
class LockInfo:
    """锁信息"""
    task_id: str
    agent_id: str           # 执行的 SubAgent ID
    started_at: datetime
    timeout_minutes: int = 30
    hostname: str = ""      # 机器标识

    def is_expired(self) -> bool:
        """检查锁是否已超时"""
        elapsed = datetime.now() - self.started_at
        return elapsed.total_seconds() > self.timeout_minutes * 60

    def to_json(self) -> str:
        """序列化为 JSON"""
        return json.dumps({
            "task_id": self.task_id,
            "agent_id": self.agent_id,
            "started_at": self.started_at.isoformat(),
            "timeout_minutes": self.timeout_minutes,
            "hostname": self.hostname,
        })

    @classmethod
    def from_json(cls, data: str) -> "LockInfo":
        """从 JSON 反序列化"""
        obj = json.loads(data)
        return cls(
            task_id=obj["task_id"],
            agent_id=obj["agent_id"],
            started_at=datetime.fromisoformat(obj["started_at"]),
            timeout_minutes=obj.get("timeout_minutes", 30),
            hostname=obj.get("hostname", ""),
        )


class LockManager:
    """锁管理器"""

    def __init__(self, cc_spec_root: Path):
        self.locks_dir = cc_spec_root / "locks"
        self.locks_dir.mkdir(parents=True, exist_ok=True)

    def acquire(
        self,
        task_id: str,
        agent_id: str,
        timeout_minutes: int = 30,
        force: bool = False,
    ) -> bool:
        """
        尝试获取任务锁

        Args:
            task_id: 任务 ID
            agent_id: 执行的 SubAgent ID
            timeout_minutes: 锁超时时间
            force: 是否强制获取 (覆盖已有锁)

        Returns:
            是否成功获取锁
        """
        lock_path = self.locks_dir / f"{task_id}.lock"

        # 检查现有锁
        if lock_path.exists() and not force:
            existing = LockInfo.from_json(lock_path.read_text())
            if not existing.is_expired():
                return False  # 锁被占用且未超时

        # 创建新锁
        lock_info = LockInfo(
            task_id=task_id,
            agent_id=agent_id,
            started_at=datetime.now(),
            timeout_minutes=timeout_minutes,
        )
        lock_path.write_text(lock_info.to_json())
        return True

    def release(self, task_id: str) -> bool:
        """释放任务锁"""
        lock_path = self.locks_dir / f"{task_id}.lock"
        if lock_path.exists():
            lock_path.unlink()
            return True
        return False

    def get_lock_info(self, task_id: str) -> LockInfo | None:
        """获取锁信息"""
        lock_path = self.locks_dir / f"{task_id}.lock"
        if lock_path.exists():
            return LockInfo.from_json(lock_path.read_text())
        return None

    def cleanup_expired(self) -> list[str]:
        """清理所有过期的锁"""
        cleaned = []
        for lock_file in self.locks_dir.glob("*.lock"):
            lock_info = LockInfo.from_json(lock_file.read_text())
            if lock_info.is_expired():
                lock_file.unlink()
                cleaned.append(lock_info.task_id)
        return cleaned
```

### 3.3 apply 集成

```python
# commands/apply.py (v1.3 修改)

async def _execute_task_with_lock(
    self,
    task: Task,
    lock_manager: LockManager,
    agent_id: str,
) -> ExecutionResult:
    """带锁执行任务"""

    # 1. 尝试获取锁
    if not lock_manager.acquire(task.task_id, agent_id):
        # 锁被占用
        lock_info = lock_manager.get_lock_info(task.task_id)
        return ExecutionResult(
            task_id=task.task_id,
            success=False,
            output="",
            error=f"Task locked by {lock_info.agent_id} since {lock_info.started_at}",
            agent_id=agent_id,
        )

    try:
        # 2. 执行任务
        result = await self._execute_task(task)
        result.agent_id = agent_id
        return result

    finally:
        # 3. 释放锁
        lock_manager.release(task.task_id)
```

## 4. 执行状态增强 (v1.3)

### 4.1 数据结构变更

```python
# subagent/executor.py (v1.3 修改)

@dataclass
class ExecutionResult:
    """任务执行结果"""
    task_id: str
    success: bool
    output: str
    error: str | None = None
    duration_seconds: float = 0.0
    started_at: datetime | None = None
    completed_at: datetime | None = None
    # v1.3 新增
    agent_id: str | None = None  # 执行的 SubAgent ID
    wave: int = 0                # 所属 Wave
    retry_count: int = 0         # 重试次数
```

```python
# core/state.py (v1.3 修改)

@dataclass
class TaskInfo:
    """任务状态信息"""
    id: str
    status: TaskStatus
    wave: int
    # v1.3 新增
    agent_id: str | None = None
    started_at: str | None = None
    completed_at: str | None = None
    error: str | None = None
    retry_count: int = 0
```

### 4.2 status.yaml v1.3 格式

```yaml
version: "1.3"
change_name: add-user-auth
created_at: "2025-01-15T10:00:00"
current_stage: apply

stages:
  specify:
    status: completed
    completed_at: "2025-01-15T10:30:00"
  clarify:
    status: completed
    completed_at: "2025-01-15T11:00:00"
  plan:
    status: completed
    completed_at: "2025-01-15T11:30:00"
  apply:
    status: in_progress
    started_at: "2025-01-15T12:00:00"
    waves_completed: 1
    waves_total: 3
  checklist:
    status: pending
  archive:
    status: pending

# v1.3: 增强的任务状态
tasks:
  - id: "01-SETUP"
    status: completed
    wave: 0
    agent_id: "agent-a1b2c3"      # v1.3 新增
    started_at: "2025-01-15T12:00:00"
    completed_at: "2025-01-15T12:05:30"
    retry_count: 0

  - id: "02-MODEL"
    status: in_progress
    wave: 1
    agent_id: "agent-d4e5f6"      # v1.3 新增
    started_at: "2025-01-15T12:06:00"
    retry_count: 0

  - id: "03-API"
    status: pending
    wave: 1
    agent_id: null
```

## 5. quick-delta 增强 (v1.3)

### 5.1 增强设计

```python
# commands/quick_delta.py (v1.3 修改)

def _parse_git_diff() -> list[FileChange]:
    """
    解析 git diff 获取文件变更列表

    Returns:
        文件变更列表，包含文件路径、变更类型、统计信息
    """
    # 获取 staged 变更
    result = subprocess.run(
        ["git", "diff", "--staged", "--name-status"],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        # 尝试获取最近一次 commit 的变更
        result = subprocess.run(
            ["git", "diff", "HEAD~1", "--name-status"],
            capture_output=True,
            text=True,
        )

    changes = []
    for line in result.stdout.strip().split("\n"):
        if not line:
            continue

        parts = line.split("\t")
        status = parts[0][0]  # A/M/D/R
        file_path = parts[1] if len(parts) > 1 else ""

        change_type = {
            "A": DeltaOperation.ADDED,
            "M": DeltaOperation.MODIFIED,
            "D": DeltaOperation.REMOVED,
            "R": DeltaOperation.RENAMED,
        }.get(status, DeltaOperation.MODIFIED)

        changes.append(FileChange(
            path=file_path,
            operation=change_type,
            old_path=parts[2] if status == "R" and len(parts) > 2 else None,
        ))

    return changes


@dataclass
class FileChange:
    """文件变更信息"""
    path: str
    operation: DeltaOperation
    old_path: str | None = None  # 用于 RENAMED
```

### 5.2 输出格式增强

```markdown
# Quick Delta: 修复按钮点击 bug

**Date**: 2025-01-15 14:30
**Commit**: abc1234def
**Author**: developer@example.com

## 文件变更

| 文件 | 类型 | 说明 |
|------|------|------|
| src/components/Button.tsx | MODIFIED | 修复 onClick 事件绑定 |
| src/styles/button.css | MODIFIED | 添加 disabled 样式 |
| src/utils/eventHelper.ts | ADDED | 新增事件辅助函数 |
| src/legacy/oldButton.tsx | REMOVED | 移除废弃组件 |

## 变更统计

- **ADDED**: 1 文件
- **MODIFIED**: 2 文件
- **REMOVED**: 1 文件
- **总计**: 4 文件, +45 行, -12 行

## 描述

修复了 Button 组件在某些情况下点击无响应的问题，
原因是事件处理函数未正确绑定 this 上下文。

同时移除了不再使用的旧版 Button 组件。
```

## 6. 配置文件 v1.3 格式

### 6.1 config.yaml

```yaml
version: "1.3"

# 多工具配置
agents:
  enabled:
    - claude
    - cursor
    - gemini
  default: claude

# 技术要求来源
tech_requirements_sources:
  - ".claude/CLAUDE.md"
  - "AGENTS.md"
  - "pyproject.toml"
  - "package.json"

# SubAgent 配置
subagent:
  max_concurrent: 10

  common:
    model: sonnet
    timeout: 300000
    permissionMode: acceptEdits
    tools: Read,Write,Edit,Glob,Grep,Bash

  profiles:
    quick:
      model: haiku
      timeout: 60000
      description: 快速任务
    heavy:
      model: opus
      timeout: 600000
      description: 复杂任务
    explore:
      model: sonnet
      timeout: 180000
      tools: Read,Glob,Grep,WebFetch,WebSearch
      description: 探索任务

# v1.3 新增: 打分配置
scoring:
  pass_threshold: 80
  auto_retry: false

  dimensions:
    functionality:
      weight: 30
      keywords: ["功能", "实现", "需求", "feature", "implement"]
    code_quality:
      weight: 25
      keywords: ["代码", "规范", "重构", "quality", "lint"]
    test_coverage:
      weight: 25
      keywords: ["测试", "test", "覆盖", "用例", "coverage"]
    documentation:
      weight: 20
      keywords: ["文档", "注释", "类型", "doc", "comment"]

# v1.3 新增: 锁配置
lock:
  timeout_minutes: 30
  use_git_commit: false  # 是否使用 git commit 锁
  cleanup_on_start: true  # 启动时清理过期锁
```

## 7. 命令列表汇总

| 命令 | 阶段 | 工具限制 | 说明 |
|------|------|----------|------|
| `cc-spec init` | 初始化 | 任意 | 初始化项目，配置多工具 |
| `cc-spec specify <desc>` | 规划 | 任意 | 生成 proposal.md |
| `cc-spec clarify` | 规划 | 任意 | 显示任务列表 |
| `cc-spec clarify <id>` | 规划 | 任意 | 标记任务返工 |
| `cc-spec plan` | 规划 | 任意 | 生成 plan.md + tasks.md |
| `/cc-spec:apply` | 执行 | **仅 Claude** | 主 Agent + SubAgent 并发 |
| `cc-spec checklist` | 验收 | 任意 | 四维度打分验收 |
| `cc-spec archive` | 归档 | 任意 | Delta 合并 + 归档 |
| `cc-spec quick-delta <desc>` | 快捷 | 任意 | 解析 git diff 快速记录 |
| `cc-spec list <type>` | 辅助 | 任意 | 列出变更/任务/归档 |
| `cc-spec goto <id>` | 辅助 | 任意 | 智能跳转 |
| `cc-spec update` | 辅助 | 任意 | 更新配置/模板/命令 |

## 8. 文件变更清单

### 8.1 修改文件

| 文件 | 变更内容 |
|------|----------|
| `core/config.py` | 添加 ScoringConfig, LockConfig |
| `core/scoring.py` | 重构为四维度打分 |
| `core/state.py` | TaskInfo 添加 agent_id 等字段 |
| `subagent/executor.py` | ExecutionResult 添加 agent_id，集成锁 |
| `commands/checklist.py` | 使用新打分机制，输出维度报告 |
| `commands/apply.py` | 集成锁管理器 |
| `commands/quick_delta.py` | 添加 git diff 解析 |

### 8.2 新增文件

| 文件 | 内容 |
|------|------|
| `core/lock.py` | LockInfo, LockManager |
| `tests/test_scoring_v13.py` | 四维度打分测试 |
| `tests/test_lock.py` | 锁机制测试 |
| `tests/test_quick_delta_v13.py` | quick-delta 增强测试 |
