# 04 - 实施步骤

## 实施阶段概览

```
Gate 0: 项目初始化
   ↓
Gate 1: 核心框架
   ↓
Gate 2: 命令实现
   ↓
Gate 3: SubAgent 集成
   ↓
Gate 4: 测试与文档
   ↓
发布
```

---

## Gate 0: 项目初始化

### 目标
建立项目基础结构，配置开发环境。

### 步骤

#### 0.1 创建项目结构

```bash
# 使用 uv 初始化
uv init cc-spec
cd cc-spec

# 创建目录结构
mkdir -p src/cc_spec/{commands,core,subagent,ui,utils}
touch src/cc_spec/__init__.py
touch src/cc_spec/__main__.py
```

#### 0.2 配置 pyproject.toml

```toml
[project]
name = "cc-spec"
version = "0.1.0"
description = "Spec-driven development CLI for Claude Code"
requires-python = ">=3.11"
dependencies = [
    "typer>=0.9.0",
    "rich>=13.0.0",
    "httpx>=0.25.0",
    "readchar>=4.0.0",
    "pyyaml>=6.0",
]

[project.scripts]
cc-spec = "cc_spec:main"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/cc_spec"]
```

#### 0.3 创建模板文件

从 Spec-Kit 迁移模板到 `templates/` 目录：
- `spec-template.md`
- `plan-template.md`
- `tasks-template.md`
- `checklist-template.md`

### 验收标准

- [ ] `uv run cc-spec --help` 显示帮助信息
- [ ] 项目结构符合设计文档
- [ ] 模板文件就绪

---

## Gate 1: 核心框架

### 目标
实现配置管理、状态管理、模板处理等核心模块。

### 步骤

#### 1.1 CLI 入口 (`__init__.py`)

```python
import typer
from rich.console import Console

app = typer.Typer(
    name="cc-spec",
    help="Spec-driven development CLI for Claude Code",
    no_args_is_help=True,
)
console = Console()

def main():
    app()

if __name__ == "__main__":
    main()
```

#### 1.2 配置管理 (`core/config.py`)

```python
from pathlib import Path
from dataclasses import dataclass
import yaml

@dataclass
class Config:
    version: str
    agent: str
    project_name: str
    subagent_max_concurrent: int = 10
    checklist_pass_threshold: int = 80

def load_config(path: Path) -> Config:
    """加载 .cc-spec/config.yaml"""
    ...

def save_config(config: Config, path: Path):
    """保存配置"""
    ...

def detect_agent() -> str:
    """检测当前使用的 AI 工具"""
    ...
```

#### 1.3 状态管理 (`core/state.py`)

```python
from enum import Enum
from dataclasses import dataclass
from datetime import datetime

class Stage(Enum):
    SPECIFY = "specify"
    CLARIFY = "clarify"
    PLAN = "plan"
    APPLY = "apply"
    CHECKLIST = "checklist"
    ARCHIVE = "archive"

class TaskStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"

@dataclass
class ChangeState:
    change_name: str
    current_stage: Stage
    stages: dict
    tasks: list

def load_state(change_dir: Path) -> ChangeState:
    """加载 status.yaml"""
    ...

def update_state(state: ChangeState, change_dir: Path):
    """更新状态"""
    ...
```

#### 1.4 模板处理 (`core/templates.py`)

```python
def download_templates(dest: Path, url: str = None):
    """下载模板到指定目录"""
    ...

def render_template(template_name: str, context: dict) -> str:
    """渲染模板"""
    ...

def copy_template(template_name: str, dest: Path, context: dict):
    """复制并渲染模板到目标路径"""
    ...
```

#### 1.5 UI 组件 (`ui/display.py`)

```python
from rich.panel import Panel
from rich.table import Table
from rich.tree import Tree
from rich.progress import Progress

def show_status_panel(state: ChangeState):
    """显示状态面板"""
    ...

def show_task_table(tasks: list):
    """显示任务表格"""
    ...

def show_wave_tree(waves: list):
    """显示 Wave 树形结构"""
    ...
```

### 验收标准

- [ ] 配置文件可正确读写
- [ ] 状态管理支持所有阶段
- [ ] 模板渲染功能正常
- [ ] UI 组件显示正确

---

## Gate 2: 命令实现

### 目标
实现所有 CLI 命令（除 apply 外）。

### 步骤

#### 2.1 init 命令

```python
# commands/init.py
@app.command()
def init(
    project: str = typer.Argument(None),
    agent: str = typer.Option(None),
    force: bool = typer.Option(False),
):
    """初始化 cc-spec 工作流"""
    # 1. 创建 .cc-spec/ 目录
    # 2. 下载/复制模板
    # 3. 创建 config.yaml
    # 4. 显示成功信息
```

#### 2.2 specify 命令

```python
# commands/specify.py
@app.command()
def specify(
    name: str = typer.Argument(...),
    template: str = typer.Option("default"),
):
    """创建变更规格"""
    # 1. 创建 changes/{name}/ 目录
    # 2. 生成 proposal.md
    # 3. 初始化 status.yaml
```

#### 2.3 clarify 命令

```python
# commands/clarify.py
@app.command()
def clarify(
    task_id: str = typer.Argument(None),
):
    """澄清需求或返工任务"""
    if task_id is None:
        show_task_list()
    else:
        rework_task(task_id)
```

#### 2.4 plan 命令

```python
# commands/plan.py
@app.command()
def plan(
    change: str = typer.Argument(None),
):
    """生成执行计划"""
    # 1. 读取 proposal.md
    # 2. 生成 tasks.md (Wave 格式)
    # 3. 生成 design.md
    # 4. 更新状态
```

#### 2.5 checklist 命令

```python
# commands/checklist.py
@app.command()
def checklist(
    change: str = typer.Argument(None),
):
    """验收打分"""
    # 1. 加载 checklist 模板
    # 2. 逐项检查
    # 3. 计算得分
    # 4. 通过/打回
```

#### 2.6 archive 命令

```python
# commands/archive.py
@app.command()
def archive(
    change: str = typer.Argument(None),
    force: bool = typer.Option(False),
):
    """归档变更"""
    # 1. 检查 checklist 状态
    # 2. 显示将更新的 specs
    # 3. 合并 Delta
    # 4. 移动到 archive/
```

#### 2.7 quick-delta 命令

```python
# commands/quick_delta.py
@app.command("quick-delta")
def quick_delta(
    message: str = typer.Argument(...),
):
    """超简单模式"""
    # 1. 生成变更名
    # 2. 创建 mini-proposal
    # 3. 直接归档
```

### 验收标准

- [ ] 所有命令可通过 `--help` 查看帮助
- [ ] init 正确创建目录和配置
- [ ] specify 生成正确的 proposal.md
- [ ] clarify 正确显示任务列表/返工流程
- [ ] plan 生成正确格式的 tasks.md
- [ ] checklist 打分机制正常工作
- [ ] archive 正确合并和移动文件
- [ ] quick-delta 一步完成记录

---

## Gate 3: SubAgent 集成

### 目标
实现 apply 命令的 SubAgent 并发执行功能。

### 步骤

#### 3.1 任务解析器 (`subagent/task_parser.py`)

```python
from dataclasses import dataclass

@dataclass
class Task:
    id: str
    wave: int
    estimated_tokens: str
    status: str
    dependencies: list
    required_docs: list
    code_entries: list
    checklist: list

@dataclass
class Wave:
    number: int
    tasks: list[Task]

def parse_tasks_md(path: Path) -> list[Wave]:
    """解析 tasks.md，返回 Wave 分组"""
    ...
```

#### 3.2 并发执行器 (`subagent/executor.py`)

```python
class SubAgentExecutor:
    def __init__(self, max_concurrent: int = 10):
        self.max_concurrent = max_concurrent

    async def execute_wave(self, wave: Wave, context: dict) -> list[Result]:
        """并发执行一个 Wave 的所有任务"""
        agents = []
        for task in wave.tasks:
            agent = self.spawn_agent(task, context)
            agents.append(agent)

        results = await self.collect_results(agents)
        return results

    def spawn_agent(self, task: Task, context: dict) -> Agent:
        """启动 SubAgent"""
        prompt = self.build_prompt(task, context)
        # 使用 Task tool 启动
        ...

    def build_prompt(self, task: Task, context: dict) -> str:
        """构建任务 Prompt"""
        ...
```

#### 3.3 结果收集器 (`subagent/result_collector.py`)

```python
@dataclass
class TaskResult:
    task_id: str
    status: str  # completed | failed | timeout | partial
    output: str
    checklist_status: dict
    duration: float

def collect_result(agent_id: str, timeout: int) -> TaskResult:
    """收集 SubAgent 结果"""
    # 使用 TaskOutput tool
    ...

def update_tasks_md(path: Path, results: list[TaskResult]):
    """更新 tasks.md 状态"""
    ...
```

#### 3.4 apply 命令 (`commands/apply.py`)

```python
@app.command()
def apply(
    change: str = typer.Argument(None),
    max_concurrent: int = typer.Option(10),
):
    """执行任务（SubAgent 并发）"""
    # 1. 加载 tasks.md
    waves = parse_tasks_md(tasks_path)

    # 2. 按 Wave 顺序执行
    executor = SubAgentExecutor(max_concurrent)
    for wave in waves:
        console.print(f"[bold]执行 Wave {wave.number}...[/bold]")
        results = executor.execute_wave(wave, context)

        # 3. 更新状态
        update_tasks_md(tasks_path, results)

        # 4. 检查是否有失败
        if any(r.status == "failed" for r in results):
            console.print("[red]存在失败任务，请使用 clarify 返工[/red]")
            break

    # 5. 更新整体状态
    update_state(state, change_dir)
```

### 验收标准

- [ ] tasks.md 解析正确
- [ ] SubAgent 可并发启动
- [ ] Wave 间串行，Wave 内并发
- [ ] 结果正确收集和记录
- [ ] 失败任务正确标记
- [ ] 超时处理正常

---

## Gate 4: 测试与文档

### 目标
完善测试覆盖和用户文档。

### 步骤

#### 4.1 单元测试

```
tests/
├── test_config.py
├── test_state.py
├── test_templates.py
├── test_task_parser.py
├── test_delta.py
└── test_scoring.py
```

#### 4.2 集成测试

```
tests/integration/
├── test_init.py
├── test_full_workflow.py
└── test_subagent.py
```

#### 4.3 用户文档

```
docs/
├── README.md           # 快速开始
├── installation.md     # 安装指南
├── commands.md         # 命令参考
├── workflow.md         # 工作流详解
├── templates.md        # 模板说明
└── troubleshooting.md  # 常见问题
```

#### 4.4 发布准备

```bash
# 构建
uv build

# 测试从仓库安装
uvx --from git+https://github.com/Waasaabii/cc-spec.git cc-spec --help

# 测试全局安装
uv tool install cc-spec --from git+https://github.com/Waasaabii/cc-spec.git
cc-spec --help

# 本地开发测试
uvx --from . cc-spec init demo --ai claude
```

**注意**: 暂不发布到 PyPI，仅通过 GitHub 仓库分发。

### 验收标准

- [ ] 单元测试覆盖率 > 80%
- [ ] 集成测试通过
- [ ] 用户文档完整
- [ ] 可通过 `uvx --from git+...` 安装使用

---

## 里程碑检查点

| Gate | 产出 | 关键验收 |
|------|------|----------|
| Gate 0 | 项目骨架 | `uv run cc-spec --help` 可用 |
| Gate 1 | 核心模块 | 配置/状态/模板/UI 正常 |
| Gate 2 | 6 个命令 | 完整工作流可走通（无 apply） |
| Gate 3 | apply 命令 | SubAgent 并发执行正常 |
| Gate 4 | 测试+文档 | 可发布到 PyPI |

---

## 风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| SubAgent API 变更 | 高 | 抽象执行层，便于适配 |
| 模板格式不兼容 | 中 | 版本化模板，提供迁移脚本 |
| 并发稳定性 | 高 | 限制默认并发数，充分测试 |
| 跨平台兼容 | 中 | 使用 pathlib，避免平台特定代码 |
