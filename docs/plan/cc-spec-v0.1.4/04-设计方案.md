# 04 - 设计方案

本文档详细描述每个缺口的实现方案，包含 API 契约、数据结构、模块设计。

---

## 4.1 命令文件生成器重写

### 设计目标
将 `command_generator.py` 的命令内容从 ~20 行扩展到 150-300 行完整工作流指令。

### 修改位置
- 文件：`src/cc_spec/core/command_generator.py`
- 函数：`_get_md_content()` (160-182 行) → 重写
- 函数：`_get_toml_content()` (184-201 行) → 重写

### 新增文件
```
src/cc_spec/core/
├── command_templates/           # 命令模板目录
│   ├── __init__.py
│   ├── base.py                  # 基础模板类
│   ├── specify_template.py      # specify 命令模板
│   ├── clarify_template.py      # clarify 命令模板
│   ├── plan_template.py         # plan 命令模板
│   ├── apply_template.py        # apply 命令模板
│   ├── checklist_template.py    # checklist 命令模板
│   └── archive_template.py      # archive 命令模板
```

### 模板基类设计

```python
# src/cc_spec/core/command_templates/base.py

from abc import ABC, abstractmethod
from dataclasses import dataclass

@dataclass
class CommandTemplateContext:
    """命令模板上下文"""
    command_name: str
    namespace: str = "cc-spec"  # 命令命名空间，统一使用 cc-spec
    project_root: str = "."
    config_sources: list[str] = None  # CLAUDE.md 等配置文件

    def __post_init__(self):
        if self.config_sources is None:
            self.config_sources = [
                ".claude/CLAUDE.md",
                "AGENTS.md",
                "pyproject.toml",
                "package.json",
            ]

class CommandTemplate(ABC):
    """命令模板抽象基类"""

    @property
    @abstractmethod
    def command_name(self) -> str:
        """命令名称"""
        ...

    @property
    @abstractmethod
    def description(self) -> str:
        """命令描述"""
        ...

    @abstractmethod
    def get_outline(self) -> str:
        """获取执行大纲"""
        ...

    @abstractmethod
    def get_execution_steps(self) -> str:
        """获取详细执行步骤"""
        ...

    @abstractmethod
    def get_validation_checklist(self) -> str:
        """获取验证检查清单"""
        ...

    def render(self, format: str = "markdown") -> str:
        """渲染完整命令内容"""
        if format == "markdown":
            return self._render_markdown()
        elif format == "toml":
            return self._render_toml()
        raise ValueError(f"Unsupported format: {format}")

    def _render_markdown(self) -> str:
        return f"""---
description: {self.description}
allowed-tools: Bash, Read, Write, Edit, Glob, Grep
---

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

## Outline

{self.get_outline()}

## Execution Steps

{self.get_execution_steps()}

## Validation Checklist

{self.get_validation_checklist()}

## Error Handling

- If any step fails, document the error and suggest recovery steps
- Do not proceed to next step if validation fails
- Maximum 3 retry attempts per step
"""
```

### specify 命令模板示例

```python
# src/cc_spec/core/command_templates/specify_template.py

class SpecifyTemplate(CommandTemplate):

    @property
    def command_name(self) -> str:
        return "specify"

    @property
    def description(self) -> str:
        return "Create or edit a change specification"

    def get_outline(self) -> str:
        return """
1. **Generate a concise short name** (2-4 words) for the change
2. **Check for existing changes** before creating new one
3. **Analyze project context** (tech stack, existing patterns)
4. **Load template** and fill with concrete details
5. **Create specification quality checklist**
6. **Run validation** and handle [NEEDS CLARIFICATION] markers
7. **Report completion** with next steps
"""

    def get_execution_steps(self) -> str:
        return """
### Step 1: Generate Short Name

Analyze the user's feature description and extract meaningful keywords:
- Use action-noun format (e.g., "add-user-auth", "fix-payment-bug")
- Preserve technical terms (OAuth2, API, JWT)
- Keep it 2-4 words

### Step 2: Check Existing Changes

```bash
# Check .cc-spec/changes/ for existing changes with similar names
ls -la .cc-spec/changes/ 2>/dev/null || echo "No existing changes"
```

If a change with similar name exists:
- Suggest editing existing change: `cc-spec specify C-XXX`
- Or confirm creating new change with different name

### Step 3: Analyze Project Context

Read project configuration files to understand context:

```bash
# Detect tech stack
cat pyproject.toml 2>/dev/null || cat package.json 2>/dev/null
```

Identify:
- **Tech Stack**: Python/Node/Go/Rust/etc.
- **Project Type**: 0→1 (new) or N→N+1 (incremental)
- **Existing Patterns**: Code conventions, module structure

### Step 4: Create Change with Template

Run the CLI command:
```bash
cc-spec specify <short-name>
```

Then fill the generated `proposal.md` with:
- **Why**: Business motivation and problem statement
- **What Changes**: Specific modifications required
- **Impact**: Affected areas and expected code changes

### Step 5: Create Validation Checklist

Generate `checklists/requirements.md` with:

```markdown
# Specification Quality Checklist

## Content Quality
- [ ] No implementation details (languages, frameworks)
- [ ] Focused on user value and business needs
- [ ] Written for non-technical stakeholders

## Requirement Completeness
- [ ] No [NEEDS CLARIFICATION] markers remain
- [ ] Requirements are testable and unambiguous
- [ ] Success criteria are measurable
```

### Step 6: Handle Clarifications

If [NEEDS CLARIFICATION] markers exist (max 3):

Present options in table format:

| Option | Answer | Implications |
|--------|--------|--------------|
| A | [First answer] | [Impact] |
| B | [Second answer] | [Impact] |
| C | [Third answer] | [Impact] |
| Custom | Your own answer | Provide details |

Wait for user response, then update the spec.

### Step 7: Report Completion

Display:
- Change ID (e.g., C-001)
- File paths created
- Next steps: `cc-spec clarify` or `cc-spec plan`
"""

    def get_validation_checklist(self) -> str:
        return """
Before completing, verify:

- [ ] Change directory created at `.cc-spec/changes/<name>/`
- [ ] `proposal.md` contains concrete details (not placeholders)
- [ ] `status.yaml` initialized with stage: specify
- [ ] Change registered with ID (C-XXX)
- [ ] No more than 3 [NEEDS CLARIFICATION] markers
- [ ] All mandatory sections filled
"""
```

### command_generator.py 修改

```python
# src/cc_spec/core/command_generator.py (修改)

from cc_spec.core.command_templates import (
    SpecifyTemplate,
    ClarifyTemplate,
    PlanTemplate,
    ApplyTemplate,
    ChecklistTemplate,
    ArchiveTemplate,
    QuickDeltaTemplate,
)

# 命令到模板的映射
COMMAND_TEMPLATES = {
    "specify": SpecifyTemplate,
    "clarify": ClarifyTemplate,
    "plan": PlanTemplate,
    "apply": ApplyTemplate,
    "checklist": ChecklistTemplate,
    "archive": ArchiveTemplate,
    "quick-delta": QuickDeltaTemplate,
    # 简单命令使用默认模板
    "list": None,
    "goto": None,
    "update": None,
}

def _get_md_content(self, cmd_name: str, description: str) -> str:
    """获取 Markdown 命令内容（重写版）"""
    template_cls = COMMAND_TEMPLATES.get(cmd_name)

    if template_cls:
        template = template_cls()
        return template.render("markdown")

    # 简单命令使用默认模板
    return self._get_simple_md_content(cmd_name, description)
```

---

## 4.2 clarify 9 大歧义分类

### 设计目标
为 clarify 命令添加自动歧义检测功能，扫描 proposal.md/spec.md 识别模糊措辞并分类。

### 修改位置
- 文件：`src/cc_spec/commands/clarify.py`
- 新增函数：`detect_ambiguities()`, `classify_ambiguity()`, `generate_clarification_questions()`

### 新增文件
```
src/cc_spec/core/
├── ambiguity/
│   ├── __init__.py
│   ├── detector.py              # 歧义检测器
│   ├── classifier.py            # 歧义分类器
│   └── question_generator.py    # 澄清问题生成器
```

### 数据结构设计

```python
# src/cc_spec/core/ambiguity/detector.py

from dataclasses import dataclass
from enum import Enum

class AmbiguityType(Enum):
    """9 大歧义分类"""
    SCOPE = "scope"              # 范围边界不清
    DATA = "data"                # 数据结构/格式未定义
    INTERFACE = "interface"      # 接口契约模糊
    BEHAVIOR = "behavior"        # 行为逻辑有歧义
    SECURITY = "security"        # 安全/权限未明确
    PERFORMANCE = "performance"  # 性能指标缺失
    ERROR_HANDLING = "error"     # 错误处理方式
    INTEGRATION = "integration"  # 集成点未定义
    PRIORITY = "priority"        # 优先级/顺序未排

@dataclass
class Ambiguity:
    """单个歧义项"""
    type: AmbiguityType
    line_number: int
    content: str
    context: str  # 周围上下文
    suggested_questions: list[str]
    severity: str = "medium"  # low/medium/high

@dataclass
class AmbiguityReport:
    """歧义检测报告"""
    file_path: str
    ambiguities: list[Ambiguity]
    total_count: int
    by_type: dict[AmbiguityType, int]

    def has_critical(self) -> bool:
        return any(a.severity == "high" for a in self.ambiguities)

# 关键词映射
AMBIGUITY_KEYWORDS = {
    AmbiguityType.SCOPE: [
        "可能", "也许", "大概", "视情况", "待定", "TBD", "或者",
        "maybe", "possibly", "might", "could", "perhaps",
    ],
    AmbiguityType.DATA: [
        "某种格式", "数据", "字段", "结构待定",
        "some format", "data structure", "TBD fields",
    ],
    AmbiguityType.INTERFACE: [
        "接口", "API", "调用方式待定", "协议",
        "interface", "API TBD", "protocol",
    ],
    AmbiguityType.BEHAVIOR: [
        "行为", "逻辑", "流程待定", "处理方式",
        "behavior", "logic TBD", "flow",
    ],
    AmbiguityType.SECURITY: [
        "权限", "认证", "授权待定", "安全",
        "permission", "auth TBD", "security",
    ],
    AmbiguityType.PERFORMANCE: [
        "性能", "响应时间", "并发量待定",
        "performance", "response time TBD", "concurrent",
    ],
    AmbiguityType.ERROR_HANDLING: [
        "错误处理", "异常", "失败时",
        "error handling", "exception", "on failure",
    ],
    AmbiguityType.INTEGRATION: [
        "集成", "对接", "第三方", "外部系统",
        "integration", "third-party", "external",
    ],
    AmbiguityType.PRIORITY: [
        "优先级", "顺序", "先后",
        "priority", "order", "sequence",
    ],
}
```

### 检测器实现

```python
# src/cc_spec/core/ambiguity/detector.py (续)

class AmbiguityDetector:
    """歧义检测器"""

    def __init__(self, keywords: dict = None):
        self.keywords = keywords or AMBIGUITY_KEYWORDS

    def detect(self, content: str, file_path: str = "") -> AmbiguityReport:
        """检测内容中的歧义"""
        ambiguities = []
        lines = content.split("\n")

        for line_num, line in enumerate(lines, 1):
            for amb_type, keywords in self.keywords.items():
                for keyword in keywords:
                    if keyword.lower() in line.lower():
                        # 获取上下文（前后各 2 行）
                        start = max(0, line_num - 3)
                        end = min(len(lines), line_num + 2)
                        context = "\n".join(lines[start:end])

                        ambiguity = Ambiguity(
                            type=amb_type,
                            line_number=line_num,
                            content=line.strip(),
                            context=context,
                            suggested_questions=self._generate_questions(amb_type, line),
                            severity=self._assess_severity(amb_type, line),
                        )
                        ambiguities.append(ambiguity)
                        break  # 每行只记录一次

        # 按类型统计
        by_type = {}
        for amb in ambiguities:
            by_type[amb.type] = by_type.get(amb.type, 0) + 1

        return AmbiguityReport(
            file_path=file_path,
            ambiguities=ambiguities,
            total_count=len(ambiguities),
            by_type=by_type,
        )

    def _generate_questions(self, amb_type: AmbiguityType, line: str) -> list[str]:
        """生成澄清问题"""
        questions_map = {
            AmbiguityType.SCOPE: [
                "这个功能的具体边界是什么？",
                "哪些用例在范围内？哪些不在？",
            ],
            AmbiguityType.DATA: [
                "数据的具体结构是什么？",
                "需要哪些字段？字段类型是什么？",
            ],
            # ... 其他类型
        }
        return questions_map.get(amb_type, ["请澄清这个需求"])

    def _assess_severity(self, amb_type: AmbiguityType, line: str) -> str:
        """评估严重程度"""
        high_severity_types = {AmbiguityType.SCOPE, AmbiguityType.SECURITY}
        if amb_type in high_severity_types:
            return "high"
        return "medium"
```

### clarify.py 修改

```python
# src/cc_spec/commands/clarify.py (新增函数)

from cc_spec.core.ambiguity import AmbiguityDetector, AmbiguityReport

def detect_and_show_ambiguities(change_dir: Path) -> AmbiguityReport | None:
    """检测变更文档中的歧义"""
    detector = AmbiguityDetector()

    # 扫描 proposal.md 和 spec.md
    files_to_scan = ["proposal.md", "spec.md"]
    all_ambiguities = []

    for filename in files_to_scan:
        file_path = change_dir / filename
        if file_path.exists():
            content = file_path.read_text(encoding="utf-8")
            report = detector.detect(content, str(file_path))
            all_ambiguities.extend(report.ambiguities)

    if not all_ambiguities:
        console.print("[green]✓[/green] No ambiguities detected")
        return None

    # 显示歧义报告
    console.print(f"\n[yellow]Found {len(all_ambiguities)} ambiguities:[/yellow]\n")

    for i, amb in enumerate(all_ambiguities[:10], 1):  # 最多显示 10 个
        console.print(f"{i}. [{amb.type.value}] Line {amb.line_number}")
        console.print(f"   {amb.content}")
        console.print(f"   [dim]Questions: {', '.join(amb.suggested_questions)}[/dim]")
        console.print()

    return AmbiguityReport(
        file_path=str(change_dir),
        ambiguities=all_ambiguities,
        total_count=len(all_ambiguities),
        by_type={},
    )
```

---

## 4.3 技术硬要求统一执行

### 设计目标
在所有 SubAgent 完成后，由主 Agent 统一执行技术检查，命令从 CLAUDE.md 读取。

### 修改位置
- 文件：`src/cc_spec/commands/apply.py`
- 新增函数：`run_tech_checks()`, `read_check_commands()`, `detect_tech_stack()`
- 调用位置：`_handle_execution_success()` 之前

### 新增文件
```
src/cc_spec/core/
├── tech_check/
│   ├── __init__.py
│   ├── reader.py                # 从配置文件读取检查命令
│   ├── detector.py              # 技术栈检测
│   └── runner.py                # 检查命令执行器
```

### 数据结构设计

```python
# src/cc_spec/core/tech_check/reader.py

from dataclasses import dataclass
from pathlib import Path
import re

@dataclass
class TechCheckConfig:
    """技术检查配置"""
    lint_commands: list[str]
    type_check_commands: list[str]
    test_commands: list[str]
    custom_commands: list[str]
    source: str  # 配置来源文件

def read_from_claude_md(project_root: Path) -> TechCheckConfig | None:
    """从 CLAUDE.md 读取检查命令"""
    claude_md = project_root / ".claude" / "CLAUDE.md"
    if not claude_md.exists():
        return None

    content = claude_md.read_text(encoding="utf-8")

    # 查找 "## 开发命令" 或类似章节
    commands_section = re.search(
        r"##\s*(开发命令|Development Commands).*?(?=\n##|\Z)",
        content,
        re.DOTALL | re.IGNORECASE,
    )

    if not commands_section:
        return None

    section_content = commands_section.group(0)

    # 提取代码块中的命令
    code_blocks = re.findall(r"```(?:bash|shell)?\n(.*?)```", section_content, re.DOTALL)

    lint_commands = []
    type_check_commands = []
    test_commands = []

    for block in code_blocks:
        for line in block.strip().split("\n"):
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            # 分类命令
            if any(k in line for k in ["ruff", "lint", "eslint", "flake8"]):
                lint_commands.append(line)
            elif any(k in line for k in ["mypy", "type-check", "tsc", "pyright"]):
                type_check_commands.append(line)
            elif any(k in line for k in ["pytest", "test", "jest", "vitest"]):
                test_commands.append(line)

    return TechCheckConfig(
        lint_commands=lint_commands,
        type_check_commands=type_check_commands,
        test_commands=test_commands,
        custom_commands=[],
        source=str(claude_md),
    )
```

### 技术栈检测

```python
# src/cc_spec/core/tech_check/detector.py

from pathlib import Path

def detect_tech_stack(project_root: Path) -> dict:
    """检测项目技术栈"""
    result = {
        "language": None,
        "package_manager": None,
        "test_framework": None,
        "lint_tool": None,
    }

    # Python 检测
    if (project_root / "pyproject.toml").exists():
        result["language"] = "python"
        result["package_manager"] = "uv" if (project_root / "uv.lock").exists() else "pip"
        result["test_framework"] = "pytest"
        result["lint_tool"] = "ruff"

    # Node.js 检测
    elif (project_root / "package.json").exists():
        result["language"] = "nodejs"
        if (project_root / "pnpm-lock.yaml").exists():
            result["package_manager"] = "pnpm"
        elif (project_root / "yarn.lock").exists():
            result["package_manager"] = "yarn"
        else:
            result["package_manager"] = "npm"
        result["test_framework"] = "jest"
        result["lint_tool"] = "eslint"

    # Go 检测
    elif (project_root / "go.mod").exists():
        result["language"] = "go"
        result["package_manager"] = "go"
        result["test_framework"] = "go test"
        result["lint_tool"] = "go vet"

    return result

def generate_default_commands(tech_stack: dict) -> TechCheckConfig:
    """根据技术栈生成默认检查命令"""
    language = tech_stack.get("language")

    if language == "python":
        return TechCheckConfig(
            lint_commands=["uv run ruff check src/"],
            type_check_commands=["uv run mypy src/"],
            test_commands=["uv run pytest"],
            custom_commands=[],
            source="auto-detected (python)",
        )
    elif language == "nodejs":
        pm = tech_stack.get("package_manager", "npm")
        return TechCheckConfig(
            lint_commands=[f"{pm} run lint"],
            type_check_commands=[f"{pm} run type-check"],
            test_commands=[f"{pm} test"],
            custom_commands=[],
            source=f"auto-detected (nodejs/{pm})",
        )
    elif language == "go":
        return TechCheckConfig(
            lint_commands=["go vet ./..."],
            type_check_commands=[],  # Go 是静态类型
            test_commands=["go test ./..."],
            custom_commands=[],
            source="auto-detected (go)",
        )

    return TechCheckConfig(
        lint_commands=[],
        type_check_commands=[],
        test_commands=[],
        custom_commands=[],
        source="unknown",
    )
```

### 执行流程修改

```python
# src/cc_spec/commands/apply.py (修改)

async def _execute_with_progress(...) -> dict[int, list[ExecutionResult]]:
    # ... 现有代码 ...

    # 所有 Wave 执行完成后
    collector.end_execution()

    # v0.1.4: 主 Agent 统一执行技术检查
    if not collector.has_failures():
        console.print("\n[cyan]Running technical checks (main agent)...[/cyan]\n")
        tech_check_result = await run_tech_checks(project_root)

        if not tech_check_result.all_passed:
            console.print("[yellow]⚠ Some technical checks failed[/yellow]")
            # 结果会影响后续的 checklist 打分

    return all_results

async def run_tech_checks(project_root: Path) -> TechCheckResult:
    """运行技术检查"""
    from cc_spec.core.tech_check import (
        read_from_claude_md,
        detect_tech_stack,
        generate_default_commands,
    )

    # 1. 尝试从 CLAUDE.md 读取
    config = read_from_claude_md(project_root)

    # 2. 如果未配置，智能检测技术栈
    if config is None:
        tech_stack = detect_tech_stack(project_root)
        config = generate_default_commands(tech_stack)
        console.print(f"[dim]Using auto-detected commands ({config.source})[/dim]")
    else:
        console.print(f"[dim]Using commands from {config.source}[/dim]")

    # 3. 执行检查命令
    results = []

    for cmd in config.lint_commands:
        result = await run_command(cmd)
        results.append(("lint", cmd, result))

    for cmd in config.type_check_commands:
        result = await run_command(cmd)
        results.append(("type-check", cmd, result))

    for cmd in config.test_commands:
        result = await run_command(cmd)
        results.append(("test", cmd, result))

    return TechCheckResult(
        results=results,
        all_passed=all(r[2].success for r in results),
    )
```

---

## 4.4 模板更新

### spec-template.md 修改

```markdown
# Feature Specification: [FEATURE NAME]

**Feature Branch**: `[###-feature-name]`
**Created**: [DATE]
**Status**: Draft
**Input**: User description: "$ARGUMENTS"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - [Brief Title] (Priority: P1)

[Describe this user journey in plain language]

**Why this priority**: [Explain the value and why it has this priority level]

**Independent Test**: [Describe how this can be tested independently -
e.g., "Can be fully tested by [specific action] and delivers [specific value]"]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

### User Story 2 - [Brief Title] (Priority: P2)
...
```

---

## 4.5 数据流总览

```
┌────────────────────────────────────────────────────────────────┐
│                     v0.1.4 数据流                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  /cc-spec:specify                                              │
│       │                                                        │
│       ├─→ CommandTemplate.render()                             │
│       │   └─→ 生成 150-300 行完整工作流指令                      │
│       │                                                        │
│       ├─→ AmbiguityDetector.detect()                           │
│       │   └─→ 9 大歧义分类检测                                  │
│       │                                                        │
│       └─→ 生成 proposal.md + requirements.md                    │
│                                                                │
│  /cc-spec:clarify                                              │
│       │                                                        │
│       ├─→ 显示歧义报告                                          │
│       └─→ 生成澄清问题 → 用户回答 → 更新文档                      │
│                                                                │
│  /cc-spec:plan                                                 │
│       │                                                        │
│       ├─→ 读取 config.yaml 的 max_concurrent                    │
│       ├─→ 九段大纲生成                                          │
│       ├─→ Gate/Wave 自动规划（任务数 ≤ max_concurrent）          │
│       └─→ 验证主 Agent 上下文 ≤ 150K                            │
│                                                                │
│  /cc-spec:apply                                                │
│       │                                                        │
│       ├─→ SubAgent 并发执行                                     │
│       │                                                        │
│       └─→ 主 Agent 技术检查                                     │
│           ├─→ 读取 CLAUDE.md 检查命令                           │
│           ├─→ 或智能检测技术栈                                  │
│           └─→ 统一执行 lint/type-check/test                     │
│                                                                │
│  /cc-spec:checklist                                            │
│       │                                                        │
│       └─→ 四维度加权打分                                        │
│           ├─→ 功能完整性 30%                                    │
│           ├─→ 代码质量 25%                                      │
│           ├─→ 测试覆盖 25%                                      │
│           └─→ 文档同步 20%                                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```