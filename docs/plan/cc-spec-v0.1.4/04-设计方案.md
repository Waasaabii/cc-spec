# 04 - 设计方案

本文档详细描述每个缺口的实现方案，包含 API 契约、数据结构、模块设计。

---

## 4.1 命令文件生成器重写

### 设计目标
将 `command_generator.py` 的命令内容从 ~20 行扩展到 150-300 行完整工作流指令。

### 修改位置
- 文件：`src/cc_spec/core/command_generator.py`
- 函数：`_get_md_content()` (160-182 行) → 重写
- 函数：`_get_toml_content()` (184-201 行) → 重写

### 新增文件
```
src/cc_spec/core/
├── command_templates/           # 命令模板目录
│   ├── __init__.py
│   ├── base.py                  # 基础模板类
│   ├── specify_template.py      # specify 命令模板
│   ├── clarify_template.py      # clarify 命令模板
│   ├── plan_template.py         # plan 命令模板
│   ├── apply_template.py        # apply 命令模板
│   ├── checklist_template.py    # checklist 命令模板
│   └── archive_template.py      # archive 命令模板
```

### 模板基类设计

```python
# src/cc_spec/core/command_templates/base.py

from abc import ABC, abstractmethod
from dataclasses import dataclass

@dataclass
class CommandTemplateContext:
    """命令模板上下文"""
    command_name: str
    namespace: str = "cc-spec"  # 命令命名空间，统一使用 cc-spec
    project_root: str = "."
    config_sources: list[str] = None  # CLAUDE.md 等配置文件

    def __post_init__(self):
        if self.config_sources is None:
            self.config_sources = [
                ".claude/CLAUDE.md",
                "AGENTS.md",
                "pyproject.toml",
                "package.json",
            ]

class CommandTemplate(ABC):
    """命令模板抽象基类"""

    @property
    @abstractmethod
    def command_name(self) -> str:
        """命令名称"""
        ...

    @property
    @abstractmethod
    def description(self) -> str:
        """命令描述"""
        ...

    @abstractmethod
    def get_outline(self) -> str:
        """获取执行大纲"""
        ...

    @abstractmethod
    def get_execution_steps(self) -> str:
        """获取详细执行步骤"""
        ...

    @abstractmethod
    def get_validation_checklist(self) -> str:
        """获取验证检查清单"""
        ...

    def render(self, format: str = "markdown") -> str:
        """渲染完整命令内容"""
        if format == "markdown":
            return self._render_markdown()
        elif format == "toml":
            return self._render_toml()
        raise ValueError(f"Unsupported format: {format}")

    def _render_markdown(self) -> str:
        return f"""---
description: {self.description}
allowed-tools: Bash, Read, Write, Edit, Glob, Grep
---

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

## Outline

{self.get_outline()}

## Execution Steps

{self.get_execution_steps()}

## Validation Checklist

{self.get_validation_checklist()}

## Error Handling

- If any step fails, document the error and suggest recovery steps
- Do not proceed to next step if validation fails
- Maximum 3 retry attempts per step
"""
```

### specify 命令模板示例

```python
# src/cc_spec/core/command_templates/specify_template.py

class SpecifyTemplate(CommandTemplate):

    @property
    def command_name(self) -> str:
        return "specify"

    @property
    def description(self) -> str:
        return "Create or edit a change specification"

    def get_outline(self) -> str:
        return """
1. **Generate a concise short name** (2-4 words) for the change
2. **Check for existing changes** before creating new one
3. **Analyze project context** (tech stack, existing patterns)
4. **Load template** and fill with concrete details
5. **Create specification quality checklist**
6. **Run validation** and handle [NEEDS CLARIFICATION] markers
7. **Report completion** with next steps
"""

    def get_execution_steps(self) -> str:
        return """
### Step 1: Generate Short Name

Analyze the user's feature description and extract meaningful keywords:
- Use action-noun format (e.g., "add-user-auth", "fix-payment-bug")
- Preserve technical terms (OAuth2, API, JWT)
- Keep it 2-4 words

### Step 2: Check Existing Changes

```bash
# Check .cc-spec/changes/ for existing changes with similar names
ls -la .cc-spec/changes/ 2>/dev/null || echo "No existing changes"
```

If a change with similar name exists:
- Suggest editing existing change: `cc-spec specify C-XXX`
- Or confirm creating new change with different name

### Step 3: Analyze Project Context

Read project configuration files to understand context:

```bash
# Detect tech stack
cat pyproject.toml 2>/dev/null || cat package.json 2>/dev/null
```

Identify:
- **Tech Stack**: Python/Node/Go/Rust/etc.
- **Project Type**: 0→1 (new) or N→N+1 (incremental)
- **Existing Patterns**: Code conventions, module structure

### Step 4: Create Change with Template

Run the CLI command:
```bash
cc-spec specify <short-name>
```

Then fill the generated `proposal.md` with:
- **Why**: Business motivation and problem statement
- **What Changes**: Specific modifications required
- **Impact**: Affected areas and expected code changes

### Step 5: Create Validation Checklist

Generate `checklists/requirements.md` with:

```markdown
# Specification Quality Checklist

## Content Quality
- [ ] No implementation details (languages, frameworks)
- [ ] Focused on user value and business needs
- [ ] Written for non-technical stakeholders

## Requirement Completeness
- [ ] No [NEEDS CLARIFICATION] markers remain
- [ ] Requirements are testable and unambiguous
- [ ] Success criteria are measurable
```

### Step 6: Handle Clarifications

If [NEEDS CLARIFICATION] markers exist (max 3):

Present options in table format:

| Option | Answer | Implications |
|--------|--------|--------------|
| A | [First answer] | [Impact] |
| B | [Second answer] | [Impact] |
| C | [Third answer] | [Impact] |
| Custom | Your own answer | Provide details |

Wait for user response, then update the spec.

### Step 7: Report Completion

Display:
- Change ID (e.g., C-001)
- File paths created
- Next steps: `cc-spec clarify` or `cc-spec plan`
"""

    def get_validation_checklist(self) -> str:
        return """
Before completing, verify:

- [ ] Change directory created at `.cc-spec/changes/<name>/`
- [ ] `proposal.md` contains concrete details (not placeholders)
- [ ] `status.yaml` initialized with stage: specify
- [ ] Change registered with ID (C-XXX)
- [ ] No more than 3 [NEEDS CLARIFICATION] markers
- [ ] All mandatory sections filled
"""
```

### command_generator.py 修改

```python
# src/cc_spec/core/command_generator.py (修改)

from cc_spec.core.command_templates import (
    SpecifyTemplate,
    ClarifyTemplate,
    PlanTemplate,
    ApplyTemplate,
    ChecklistTemplate,
    ArchiveTemplate,
    QuickDeltaTemplate,
)

# 命令到模板的映射
COMMAND_TEMPLATES = {
    "specify": SpecifyTemplate,
    "clarify": ClarifyTemplate,
    "plan": PlanTemplate,
    "apply": ApplyTemplate,
    "checklist": ChecklistTemplate,
    "archive": ArchiveTemplate,
    "quick-delta": QuickDeltaTemplate,
    # 简单命令使用默认模板
    "list": None,
    "goto": None,
    "update": None,
}

def _get_md_content(self, cmd_name: str, description: str) -> str:
    """获取 Markdown 命令内容（重写版）"""
    template_cls = COMMAND_TEMPLATES.get(cmd_name)

    if template_cls:
        template = template_cls()
        return template.render("markdown")

    # 简单命令使用默认模板
    return self._get_simple_md_content(cmd_name, description)
```

---

## 4.2 clarify 9 大歧义分类

### 设计目标
为 clarify 命令添加自动歧义检测功能，扫描 proposal.md/spec.md 识别模糊措辞并分类。

### 修改位置
- 文件：`src/cc_spec/commands/clarify.py`
- 新增函数：`detect_ambiguities()`, `classify_ambiguity()`, `generate_clarification_questions()`

### 新增文件
```
src/cc_spec/core/
├── ambiguity/
│   ├── __init__.py
│   ├── detector.py              # 歧义检测器
│   ├── classifier.py            # 歧义分类器
│   └── question_generator.py    # 澄清问题生成器
```

### 数据结构设计

```python
# src/cc_spec/core/ambiguity/detector.py

from dataclasses import dataclass
from enum import Enum

class AmbiguityType(Enum):
    """9 大歧义分类"""
    SCOPE = "scope"              # 范围边界不清
    DATA = "data"                # 数据结构/格式未定义
    INTERFACE = "interface"      # 接口契约模糊
    BEHAVIOR = "behavior"        # 行为逻辑有歧义
    SECURITY = "security"        # 安全/权限未明确
    PERFORMANCE = "performance"  # 性能指标缺失
    ERROR_HANDLING = "error"     # 错误处理方式
    INTEGRATION = "integration"  # 集成点未定义
    PRIORITY = "priority"        # 优先级/顺序未排

@dataclass
class Ambiguity:
    """单个歧义项"""
    type: AmbiguityType
    line_number: int
    content: str
    context: str  # 周围上下文
    suggested_questions: list[str]
    severity: str = "medium"  # low/medium/high

@dataclass
class AmbiguityReport:
    """歧义检测报告"""
    file_path: str
    ambiguities: list[Ambiguity]
    total_count: int
    by_type: dict[AmbiguityType, int]

    def has_critical(self) -> bool:
        return any(a.severity == "high" for a in self.ambiguities)

# 关键词映射
AMBIGUITY_KEYWORDS = {
    AmbiguityType.SCOPE: [
        "可能", "也许", "大概", "视情况", "待定", "TBD", "或者",
        "maybe", "possibly", "might", "could", "perhaps",
    ],
    AmbiguityType.DATA: [
        "某种格式", "数据", "字段", "结构待定",
        "some format", "data structure", "TBD fields",
    ],
    AmbiguityType.INTERFACE: [
        "接口", "API", "调用方式待定", "协议",
        "interface", "API TBD", "protocol",
    ],
    AmbiguityType.BEHAVIOR: [
        "行为", "逻辑", "流程待定", "处理方式",
        "behavior", "logic TBD", "flow",
    ],
    AmbiguityType.SECURITY: [
        "权限", "认证", "授权待定", "安全",
        "permission", "auth TBD", "security",
    ],
    AmbiguityType.PERFORMANCE: [
        "性能", "响应时间", "并发量待定",
        "performance", "response time TBD", "concurrent",
    ],
    AmbiguityType.ERROR_HANDLING: [
        "错误处理", "异常", "失败时",
        "error handling", "exception", "on failure",
    ],
    AmbiguityType.INTEGRATION: [
        "集成", "对接", "第三方", "外部系统",
        "integration", "third-party", "external",
    ],
    AmbiguityType.PRIORITY: [
        "优先级", "顺序", "先后",
        "priority", "order", "sequence",
    ],
}
```

### 检测器实现

```python
# src/cc_spec/core/ambiguity/detector.py (续)

class AmbiguityDetector:
    """歧义检测器"""

    def __init__(self, keywords: dict = None):
        self.keywords = keywords or AMBIGUITY_KEYWORDS

    def detect(self, content: str, file_path: str = "") -> AmbiguityReport:
        """检测内容中的歧义"""
        ambiguities = []
        lines = content.split("\n")

        for line_num, line in enumerate(lines, 1):
            for amb_type, keywords in self.keywords.items():
                for keyword in keywords:
                    if keyword.lower() in line.lower():
                        # 获取上下文（前后各 2 行）
                        start = max(0, line_num - 3)
                        end = min(len(lines), line_num + 2)
                        context = "\n".join(lines[start:end])

                        ambiguity = Ambiguity(
                            type=amb_type,
                            line_number=line_num,
                            content=line.strip(),
                            context=context,
                            suggested_questions=self._generate_questions(amb_type, line),
                            severity=self._assess_severity(amb_type, line),
                        )
                        ambiguities.append(ambiguity)
                        break  # 每行只记录一次

        # 按类型统计
        by_type = {}
        for amb in ambiguities:
            by_type[amb.type] = by_type.get(amb.type, 0) + 1

        return AmbiguityReport(
            file_path=file_path,
            ambiguities=ambiguities,
            total_count=len(ambiguities),
            by_type=by_type,
        )

    def _generate_questions(self, amb_type: AmbiguityType, line: str) -> list[str]:
        """生成澄清问题"""
        questions_map = {
            AmbiguityType.SCOPE: [
                "这个功能的具体边界是什么？",
                "哪些用例在范围内？哪些不在？",
            ],
            AmbiguityType.DATA: [
                "数据的具体结构是什么？",
                "需要哪些字段？字段类型是什么？",
            ],
            # ... 其他类型
        }
        return questions_map.get(amb_type, ["请澄清这个需求"])

    def _assess_severity(self, amb_type: AmbiguityType, line: str) -> str:
        """评估严重程度"""
        high_severity_types = {AmbiguityType.SCOPE, AmbiguityType.SECURITY}
        if amb_type in high_severity_types:
            return "high"
        return "medium"
```

### clarify.py 修改

```python
# src/cc_spec/commands/clarify.py (新增函数)

from cc_spec.core.ambiguity import AmbiguityDetector, AmbiguityReport

def detect_and_show_ambiguities(change_dir: Path) -> AmbiguityReport | None:
    """检测变更文档中的歧义"""
    detector = AmbiguityDetector()

    # 扫描 proposal.md 和 spec.md
    files_to_scan = ["proposal.md", "spec.md"]
    all_ambiguities = []

    for filename in files_to_scan:
        file_path = change_dir / filename
        if file_path.exists():
            content = file_path.read_text(encoding="utf-8")
            report = detector.detect(content, str(file_path))
            all_ambiguities.extend(report.ambiguities)

    if not all_ambiguities:
        console.print("[green]✓[/green] No ambiguities detected")
        return None

    # 显示歧义报告
    console.print(f"\n[yellow]Found {len(all_ambiguities)} ambiguities:[/yellow]\n")

    for i, amb in enumerate(all_ambiguities[:10], 1):  # 最多显示 10 个
        console.print(f"{i}. [{amb.type.value}] Line {amb.line_number}")
        console.print(f"   {amb.content}")
        console.print(f"   [dim]Questions: {', '.join(amb.suggested_questions)}[/dim]")
        console.print()

    return AmbiguityReport(
        file_path=str(change_dir),
        ambiguities=all_ambiguities,
        total_count=len(all_ambiguities),
        by_type={},
    )
```

---

## 4.3 技术硬要求统一执行

### 设计目标
在所有 SubAgent 完成后，由主 Agent 统一执行技术检查，命令从 CLAUDE.md 读取。

### 修改位置
- 文件：`src/cc_spec/commands/apply.py`
- 新增函数：`run_tech_checks()`, `read_check_commands()`, `detect_tech_stack()`
- 调用位置：`_handle_execution_success()` 之前

### 新增文件
```
src/cc_spec/core/
├── tech_check/
│   ├── __init__.py
│   ├── reader.py                # 从配置文件读取检查命令
│   ├── detector.py              # 技术栈检测
│   └── runner.py                # 检查命令执行器
```

### 数据结构设计

```python
# src/cc_spec/core/tech_check/reader.py

from dataclasses import dataclass
from pathlib import Path
import re

@dataclass
class TechCheckConfig:
    """技术检查配置"""
    lint_commands: list[str]
    type_check_commands: list[str]
    test_commands: list[str]
    custom_commands: list[str]
    source: str  # 配置来源文件

def read_from_claude_md(project_root: Path) -> TechCheckConfig | None:
    """从 CLAUDE.md 读取检查命令"""
    claude_md = project_root / ".claude" / "CLAUDE.md"
    if not claude_md.exists():
        return None

    content = claude_md.read_text(encoding="utf-8")

    # 查找 "## 开发命令" 或类似章节
    commands_section = re.search(
        r"##\s*(开发命令|Development Commands).*?(?=\n##|\Z)",
        content,
        re.DOTALL | re.IGNORECASE,
    )

    if not commands_section:
        return None

    section_content = commands_section.group(0)

    # 提取代码块中的命令
    code_blocks = re.findall(r"```(?:bash|shell)?\n(.*?)```", section_content, re.DOTALL)

    lint_commands = []
    type_check_commands = []
    test_commands = []

    for block in code_blocks:
        for line in block.strip().split("\n"):
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            # 分类命令
            if any(k in line for k in ["ruff", "lint", "eslint", "flake8"]):
                lint_commands.append(line)
            elif any(k in line for k in ["mypy", "type-check", "tsc", "pyright"]):
                type_check_commands.append(line)
            elif any(k in line for k in ["pytest", "test", "jest", "vitest"]):
                test_commands.append(line)

    return TechCheckConfig(
        lint_commands=lint_commands,
        type_check_commands=type_check_commands,
        test_commands=test_commands,
        custom_commands=[],
        source=str(claude_md),
    )
```

### 技术栈检测

```python
# src/cc_spec/core/tech_check/detector.py

from pathlib import Path

def detect_tech_stack(project_root: Path) -> dict:
    """检测项目技术栈"""
    result = {
        "language": None,
        "package_manager": None,
        "test_framework": None,
        "lint_tool": None,
    }

    # Python 检测
    if (project_root / "pyproject.toml").exists():
        result["language"] = "python"
        result["package_manager"] = "uv" if (project_root / "uv.lock").exists() else "pip"
        result["test_framework"] = "pytest"
        result["lint_tool"] = "ruff"

    # Node.js 检测
    elif (project_root / "package.json").exists():
        result["language"] = "nodejs"
        if (project_root / "pnpm-lock.yaml").exists():
            result["package_manager"] = "pnpm"
        elif (project_root / "yarn.lock").exists():
            result["package_manager"] = "yarn"
        else:
            result["package_manager"] = "npm"
        result["test_framework"] = "jest"
        result["lint_tool"] = "eslint"

    # Go 检测
    elif (project_root / "go.mod").exists():
        result["language"] = "go"
        result["package_manager"] = "go"
        result["test_framework"] = "go test"
        result["lint_tool"] = "go vet"

    return result

def generate_default_commands(tech_stack: dict) -> TechCheckConfig:
    """根据技术栈生成默认检查命令"""
    language = tech_stack.get("language")

    if language == "python":
        return TechCheckConfig(
            lint_commands=["uv run ruff check src/"],
            type_check_commands=["uv run mypy src/"],
            test_commands=["uv run pytest"],
            custom_commands=[],
            source="auto-detected (python)",
        )
    elif language == "nodejs":
        pm = tech_stack.get("package_manager", "npm")
        return TechCheckConfig(
            lint_commands=[f"{pm} run lint"],
            type_check_commands=[f"{pm} run type-check"],
            test_commands=[f"{pm} test"],
            custom_commands=[],
            source=f"auto-detected (nodejs/{pm})",
        )
    elif language == "go":
        return TechCheckConfig(
            lint_commands=["go vet ./..."],
            type_check_commands=[],  # Go 是静态类型
            test_commands=["go test ./..."],
            custom_commands=[],
            source="auto-detected (go)",
        )

    return TechCheckConfig(
        lint_commands=[],
        type_check_commands=[],
        test_commands=[],
        custom_commands=[],
        source="unknown",
    )
```

### 执行流程修改

```python
# src/cc_spec/commands/apply.py (修改)

async def _execute_with_progress(...) -> dict[int, list[ExecutionResult]]:
    # ... 现有代码 ...

    # 所有 Wave 执行完成后
    collector.end_execution()

    # v0.1.4: 主 Agent 统一执行技术检查
    if not collector.has_failures():
        console.print("\n[cyan]Running technical checks (main agent)...[/cyan]\n")
        tech_check_result = await run_tech_checks(project_root)

        if not tech_check_result.all_passed:
            console.print("[yellow]⚠ Some technical checks failed[/yellow]")
            # 结果会影响后续的 checklist 打分

    return all_results

async def run_tech_checks(project_root: Path) -> TechCheckResult:
    """运行技术检查"""
    from cc_spec.core.tech_check import (
        read_from_claude_md,
        detect_tech_stack,
        generate_default_commands,
    )

    # 1. 尝试从 CLAUDE.md 读取
    config = read_from_claude_md(project_root)

    # 2. 如果未配置，智能检测技术栈
    if config is None:
        tech_stack = detect_tech_stack(project_root)
        config = generate_default_commands(tech_stack)
        console.print(f"[dim]Using auto-detected commands ({config.source})[/dim]")
    else:
        console.print(f"[dim]Using commands from {config.source}[/dim]")

    # 3. 执行检查命令
    results = []

    for cmd in config.lint_commands:
        result = await run_command(cmd)
        results.append(("lint", cmd, result))

    for cmd in config.type_check_commands:
        result = await run_command(cmd)
        results.append(("type-check", cmd, result))

    for cmd in config.test_commands:
        result = await run_command(cmd)
        results.append(("test", cmd, result))

    return TechCheckResult(
        results=results,
        all_passed=all(r[2].success for r in results),
    )
```

---

## 4.4 模板更新

### spec-template.md 修改

```markdown
# Feature Specification: [FEATURE NAME]

**Feature Branch**: `[###-feature-name]`
**Created**: [DATE]
**Status**: Draft
**Input**: User description: "$ARGUMENTS"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - [Brief Title] (Priority: P1)

[Describe this user journey in plain language]

**Why this priority**: [Explain the value and why it has this priority level]

**Independent Test**: [Describe how this can be tested independently -
e.g., "Can be fully tested by [specific action] and delivers [specific value]"]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

### User Story 2 - [Brief Title] (Priority: P2)
...
```

---

## 4.5 数据流总览

```
┌────────────────────────────────────────────────────────────────┐
│                     v0.1.4 数据流                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  /cc-spec:specify                                              │
│       │                                                        │
│       ├─→ CommandTemplate.render()                             │
│       │   └─→ 生成 150-300 行完整工作流指令                      │
│       │                                                        │
│       ├─→ AmbiguityDetector.detect()                           │
│       │   └─→ 9 大歧义分类检测                                  │
│       │                                                        │
│       └─→ 生成 proposal.md + requirements.md                    │
│                                                                │
│  /cc-spec:clarify                                              │
│       │                                                        │
│       ├─→ 显示歧义报告                                          │
│       └─→ 生成澄清问题 → 用户回答 → 更新文档                      │
│                                                                │
│  /cc-spec:plan                                                 │
│       │                                                        │
│       ├─→ 读取 config.yaml 的 max_concurrent                    │
│       ├─→ 九段大纲生成                                          │
│       ├─→ Gate/Wave 自动规划（任务数 ≤ max_concurrent）          │
│       └─→ 验证主 Agent 上下文 ≤ 150K                            │
│                                                                │
│  /cc-spec:apply                                                │
│       │                                                        │
│       ├─→ SubAgent 并发执行                                     │
│       │                                                        │
│       └─→ 主 Agent 技术检查                                     │
│           ├─→ 读取 CLAUDE.md 检查命令                           │
│           ├─→ 或智能检测技术栈                                  │
│           └─→ 统一执行 lint/type-check/test                     │
│                                                                │
│  /cc-spec:checklist                                            │
│       │                                                        │
│       └─→ 四维度加权打分                                        │
│           ├─→ 功能完整性 30%                                    │
│           ├─→ 代码质量 25%                                      │
│           ├─→ 测试覆盖 25%                                      │
│           └─→ 文档同步 20%                                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 4.6 单一真相源设计

### 设计目标

合并 `proposal.md` 和 `design.md` 为统一的 `proposal.md`，消除文档重复。

### proposal.md 新结构

```markdown
# 变更提案: [变更名称]

**变更 ID**: C-XXX
**创建时间**: [DATE]
**状态**: Draft

## 1. 背景与目标

### 问题陈述
(描述要解决的问题)

### 业务价值
(为什么需要这个变更)

## 2. 用户故事

### User Story 1 - [标题] (优先级: P1)

**验收场景**:
1. **Given** [前置条件], **When** [操作], **Then** [预期结果]

## 3. 技术决策

### 架构选型
(技术方案选择及理由)

### 模块设计
(涉及的模块及修改范围)

### 接口定义
(新增或修改的接口)

## 4. 成功标准

- [ ] 功能验收标准 1
- [ ] 功能验收标准 2
- [ ] 性能指标（如适用）
```

### 修改位置

- `src/cc_spec/commands/specify.py`: 生成合并后的 proposal.md
- `src/cc_spec/commands/plan.py`: 移除 design.md 生成逻辑
- `src/cc_spec/templates/`: 更新模板文件

---

## 4.7 结构化任务设计

### 设计目标

将 `tasks.md`（Markdown，~3000 tokens）改为 `tasks.yaml`（YAML，~500 tokens）。

### tasks.yaml 结构

```yaml
# .cc-spec/changes/<change-name>/tasks.yaml

meta:
  change_id: C-001
  change_name: add-oauth
  max_concurrent: 10
  created_at: 2024-01-01T00:00:00Z

waves:
  - id: 0
    type: gate  # 串行执行
    tasks:
      - id: T01
        name: 初始化项目结构
        estimate: 30k
        refs:
          - src/
          - tests/
        checklist: $templates/setup-checklist

  - id: 1
    type: wave  # 并行执行
    tasks:
      - id: T02
        name: 实现登录功能
        deps: [T01]
        estimate: 50k
        refs:
          - src/auth/login.py
          - src/auth/models.py
        checklist: $templates/feature-checklist

      - id: T03
        name: 实现注册功能
        deps: [T01]
        estimate: 40k
        refs:
          - src/auth/register.py
        checklist: $templates/feature-checklist

  - id: 2
    type: wave
    tasks:
      - id: T04
        name: 集成测试
        deps: [T02, T03]
        estimate: 30k
        refs:
          - tests/integration/
        checklist: $templates/test-checklist
```

### 解析器设计

```python
# src/cc_spec/subagent/task_parser.py (修改)

from dataclasses import dataclass
import yaml

@dataclass
class TaskDefinition:
    """任务定义（从 tasks.yaml 解析）"""
    id: str
    name: str
    deps: list[str]
    estimate: str
    refs: list[str]
    checklist_ref: str  # $templates/xxx 引用

def parse_tasks_yaml(yaml_path: Path) -> list[TaskDefinition]:
    """解析 tasks.yaml 文件"""
    content = yaml_path.read_text(encoding="utf-8")
    data = yaml.safe_load(content)

    tasks = []
    for wave in data.get("waves", []):
        for task_data in wave.get("tasks", []):
            task = TaskDefinition(
                id=task_data["id"],
                name=task_data["name"],
                deps=task_data.get("deps", []),
                estimate=task_data.get("estimate", ""),
                refs=task_data.get("refs", []),
                checklist_ref=task_data.get("checklist", ""),
            )
            tasks.append(task)

    return tasks
```

---

## 4.8 SubAgent 上下文优化

### 设计目标

将每个 SubAgent 的上下文从 ~5K tokens 降低到 ~500 tokens。

### 主 Agent 预处理

```python
# src/cc_spec/commands/apply.py (新增)

def _generate_context_summary(proposal_path: Path) -> str:
    """生成变更摘要供 SubAgent 使用"""
    content = proposal_path.read_text(encoding="utf-8")

    # 提取关键章节
    summary_parts = []

    # 提取背景（前 200 字符）
    if "## 1. 背景与目标" in content:
        section = content.split("## 1. 背景与目标")[1].split("##")[0]
        summary_parts.append(f"背景: {section[:200].strip()}...")

    # 提取技术决策要点
    if "## 3. 技术决策" in content:
        section = content.split("## 3. 技术决策")[1].split("##")[0]
        summary_parts.append(f"技术方案: {section[:300].strip()}...")

    return "\n".join(summary_parts)

def _prepare_subagent_context(
    task: TaskDefinition,
    summary: str,
    templates_dir: Path,
) -> str:
    """为 SubAgent 准备精简上下文"""
    # 解析检查清单引用
    checklist_content = ""
    if task.checklist_ref.startswith("$templates/"):
        template_name = task.checklist_ref.replace("$templates/", "")
        template_path = templates_dir / f"{template_name}.md"
        if template_path.exists():
            checklist_content = template_path.read_text(encoding="utf-8")

    return f"""## 变更摘要
{summary}

## 当前任务
- ID: {task.id}
- 名称: {task.name}
- 依赖: {', '.join(task.deps) or '无'}

## 相关文件
{chr(10).join(f'- {ref}' for ref in task.refs)}

## 检查清单
{checklist_content}
"""
```

### 上下文对比

| 组成部分 | 优化前 | 优化后 |
|----------|--------|--------|
| proposal.md 完整内容 | ~2000 tokens | 0 |
| design.md 完整内容 | ~1000 tokens | 0 |
| tasks.md 完整内容 | ~2000 tokens | 0 |
| 变更摘要 | 0 | ~200 tokens |
| 当前任务定义 | 0 | ~100 tokens |
| 相关文件路径 | 0 | ~50 tokens |
| 检查清单 | 内联 | ~150 tokens (引用) |
| **总计** | **~5000 tokens** | **~500 tokens** |

---

## 4.9 公共模板引用机制

### 设计目标

通过 `$templates/` 引用机制复用公共检查清单，避免在 tasks.yaml 中重复定义。

### 目录结构

```
.cc-spec/
├── templates/
│   ├── setup-checklist.md      # 初始化任务检查清单
│   ├── feature-checklist.md    # 功能开发检查清单
│   ├── test-checklist.md       # 测试任务检查清单
│   └── refactor-checklist.md   # 重构任务检查清单
```

### 模板示例

```markdown
# setup-checklist.md

## 初始化任务检查清单

- [ ] 目录结构已创建
- [ ] 配置文件已生成
- [ ] 依赖已安装
- [ ] 基础测试通过
```

```markdown
# feature-checklist.md

## 功能开发检查清单

- [ ] 功能代码已实现
- [ ] 单元测试已编写
- [ ] 类型注解完整
- [ ] 文档字符串已添加
- [ ] 代码通过 lint 检查
```

### 引用解析

```python
# src/cc_spec/core/templates.py (新增)

def resolve_template_ref(ref: str, templates_dir: Path) -> str | None:
    """解析模板引用，返回模板内容"""
    if not ref.startswith("$templates/"):
        return None

    template_name = ref.replace("$templates/", "")
    # 支持带或不带 .md 后缀
    if not template_name.endswith(".md"):
        template_name += ".md"

    template_path = templates_dir / template_name
    if template_path.exists():
        return template_path.read_text(encoding="utf-8")

    return None
```

---

## 4.10 歧义检测逻辑改进

### 设计目标

改进歧义检测，增加上下文判断逻辑，避免误报。

### 问题

当前简单关键词匹配会将"数据结构已定义"误标记为歧义。

### 改进方案

```python
# src/cc_spec/core/ambiguity/detector.py (改进)

def _is_false_positive(self, keyword: str, line: str, context: str) -> bool:
    """判断是否为误报"""
    # 否定词列表
    negative_patterns = [
        "已定义", "已确定", "已明确", "不需要",
        "is defined", "is specified", "not required",
    ]

    # 检查是否包含否定词
    for pattern in negative_patterns:
        if pattern in line.lower():
            return True

    # 检查上下文是否包含具体定义
    if "```" in context:  # 代码块通常意味着已定义
        return True

    return False

def detect(self, content: str, file_path: str = "") -> AmbiguityReport:
    """检测内容中的歧义（含误报过滤）"""
    ambiguities = []
    lines = content.split("\n")

    for line_num, line in enumerate(lines, 1):
        for amb_type, keywords in self.keywords.items():
            for keyword in keywords:
                if keyword.lower() in line.lower():
                    # 获取上下文
                    start = max(0, line_num - 3)
                    end = min(len(lines), line_num + 2)
                    context = "\n".join(lines[start:end])

                    # 误报过滤
                    if self._is_false_positive(keyword, line, context):
                        continue

                    # ... 创建 Ambiguity 对象
```

---

## 4.11 技术检查失败处理策略

### 设计目标

明确技术检查失败后的处理策略。

### 策略定义

| 检查类型 | 失败处理 | 说明 |
|----------|----------|------|
| lint | 警告继续 | 代码风格问题不阻断流程 |
| type-check | 警告继续 | 类型问题记录但不阻断 |
| test | **阻断执行** | 测试失败必须修复 |

### 实现

```python
# src/cc_spec/core/tech_check/runner.py

@dataclass
class CheckResult:
    """单个检查结果"""
    check_type: str  # lint/type-check/test
    command: str
    success: bool
    output: str
    blocking: bool  # 是否阻断

BLOCKING_CHECKS = {"test"}  # 阻断执行的检查类型

async def run_tech_checks(project_root: Path) -> TechCheckResult:
    """运行技术检查"""
    results = []
    should_block = False

    for cmd in config.lint_commands:
        result = await run_command(cmd)
        results.append(CheckResult(
            check_type="lint",
            command=cmd,
            success=result.success,
            output=result.output,
            blocking=False,
        ))
        if not result.success:
            console.print(f"[yellow]⚠ lint 检查未通过，继续执行[/yellow]")

    for cmd in config.test_commands:
        result = await run_command(cmd)
        blocking = "test" in BLOCKING_CHECKS
        results.append(CheckResult(
            check_type="test",
            command=cmd,
            success=result.success,
            output=result.output,
            blocking=blocking,
        ))
        if not result.success and blocking:
            console.print(f"[red]✗ 测试失败，阻断执行[/red]")
            should_block = True

    return TechCheckResult(
        results=results,
        all_passed=all(r.success for r in results),
        should_block=should_block,
    )
```

---

## 4.12 数据流总览（更新后）

```
┌────────────────────────────────────────────────────────────────┐
│                     v0.1.4 数据流（新架构）                       │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  /cc-spec:specify                                              │
│       │                                                        │
│       └─→ 生成 proposal.md（单一真相源，含技术决策）              │
│                                                                │
│  /cc-spec:plan                                                 │
│       │                                                        │
│       ├─→ 读取 config.yaml 的 max_concurrent                    │
│       └─→ 生成 tasks.yaml（结构化，~500 tokens）                 │
│                                                                │
│  /cc-spec:apply                                                │
│       │                                                        │
│       ├─→ 主 Agent 预处理                                       │
│       │   ├─→ 读取 proposal.md → 生成摘要                       │
│       │   └─→ 解析 tasks.yaml → 分配任务                        │
│       │                                                        │
│       ├─→ SubAgent 并发执行（每个 ~500 tokens 上下文）           │
│       │   └─→ 引用 $templates/ 检查清单                         │
│       │                                                        │
│       └─→ 主 Agent 技术检查                                     │
│           ├─→ lint/type-check: 警告继续                         │
│           └─→ test: 失败阻断                                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```